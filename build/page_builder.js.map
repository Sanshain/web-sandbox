{"version":3,"file":"page_builder.js","sources":["../node_modules/@emmetio/scanner/scanner.es.js","../node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../node_modules/emmet/dist/emmet.es.js","../source/features/compiler.js","../source/utils/page_generator.js","../source/utils/linter.js","../source/ui/ChoiceMenu.js","../source/features/base.js","../source/pageBuilder.js","../source/utils/utils.js","../source/features/expantion.js","../source/utils/autocompletion.js","../source/features/tabs.js","../source/aceInitialize.js","../source/features/resizing.js","../source/features/consoleDebug.js","../source/main.js"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n","import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n","//@ts-check\r\n\r\n\r\n\r\n\r\nconst reactCompiler = {\r\n    react: 'https://unpkg.com/react@17/umd/react.production.min.js',\r\n    reactDOM: 'https://unpkg.com/react-dom@17/umd/react-dom.production.min.js',\r\n}\r\n\r\nconst vueCompiler = {\r\n    // vue: \"https://unpkg.com/vue@2.5.17/dist/vue.js\"\r\n    vue: 'https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.14/vue.min.js'\r\n}\r\n\r\nconst preactCompiler = {\r\n    // set: './build/_preact.js',\r\n    // set: '~/build/_preact.js',\r\n\r\n    // preact: 'https://cdnjs.cloudflare.com/ajax/libs/preact/11.0.0-experimental.1/preact.umd.min.js',     // preact\r\n    // hooks: 'https://cdnjs.cloudflare.com/ajax/libs/preact/11.0.0-experimental.1/hooks.umd.min.js',      // hooks\r\n    // compat: 'https://cdnjs.cloudflare.com/ajax/libs/preact/11.0.0-experimental.1/compat.umd.min.js'     // react\r\n\r\n    // set: 'http://127.0.0.1:3000/build/_preact.js',\r\n\r\n    set: document.location.origin + (~document.location.host.indexOf('3000') ? '/build/_preact.js' : '/static/js/compiler_libs/_preact.js'),\r\n}\r\n\r\n\r\nexport const babelCompiler = {\r\n    link: 'https://unpkg.com/@babel/standalone/babel.min.js',\r\n    mode: ' type=\"text/babel\" '\r\n}\r\n\r\n\r\n// export const reactCompilers = [babelCompiler.link, reactCompiler.react, reactCompiler.reactDOM];\r\n\r\n// export const reactCompilers = [\r\n//     preactCompiler.set,\r\n//     babelCompiler.link,\r\n// ];\r\n\r\n// export const reactCompilers = [\r\n//     vueCompiler.vue\r\n// ];\r\n\r\n\r\nexport const compilers = {\r\n    vanile: [],\r\n    preact: [babelCompiler.link].concat(Object.values(preactCompiler)),\r\n    vue: Object.values(vueCompiler),\r\n    react: [babelCompiler.link].concat(Object.values(reactCompiler)),    \r\n};\r\n\r\n\r\nexport const defaultValues = [\r\n    // html\r\n    {\r\n        html: '<h2 onclick=\"greeting(event)\">\\n\\tHello world!\\n</h2>',\r\n        css: 'h2 {\\n\\tcolor: orangered;\\n\\tcursor: pointer; \\n\\tfont-family: arial;\\n}',\r\n        javascript: 'function greeting(event){\\n\\talert(\"greeting!\")\\n}'\r\n    },\r\n    // preact\r\n    {\r\n        html: '<div id=\"root\"></div>',\r\n        css: '#root{\\n\\tcolor: orangered;\\n\\tfont-family: arial;\\n}',\r\n        javascript: \"const name = 'world'; \\nrender(\\n\\t<h1>Hello {name}</h1>, \\n\\tdocument.getElementById('root')\\n);\"\r\n    },\r\n    // vue\r\n    {\r\n        html: '<div id=\"app\">\\n\\t<input type=\"text\" v-on:input=\"setMsg\" />\\n\\t<p>{{msg}}</p>\\n</div>',\r\n        css: '#app { \\n\\tcolor: green; \\n}',\r\n        javascript: \"new Vue({\\n\\tel: '#app', \\n\\tdata: {\\n\\t\\tmsg: 'Hello Vue!'\\n\\t}, \\n\\tmethods: {\\n\\t\\tsetMsg: function(e){\\n\\t\\t\\tthis.msg = e.target.value;\\n\\t\\t}\\n\\t}\\n})\"\r\n    },\r\n    // react\r\n    {\r\n        html: '<div id=\"root\"></div>',\r\n        css: '#root{\\n\\tcolor: red;\\n\\tfont-family: arial;\\n}\\nh1{\\n\\tcursor: pointer;\\n\\tuser-select: none;\\n}',\r\n        // javascript: \"const name = 'world'; \\n\\nReactDOM.render(\\n\\t<h1>Привет, {name}!</h1>, \\n\\tdocument.getElementById('root')\\n);\"\r\n        javascript: \"function App(){\\n\\n\\tconst [count, setCount] = React.useState(0);\\n\" +\r\n                    \"\\n\\treturn <h1 onClick={()=>setCount(count+1)}>\\n\\t\\tClick me: {count}!\\n\\t</h1>;\\n}\\n\\nReactDOM.render(\\n\\t<App/>,\\n\\tdocument.getElementById('root')\\n);\"\r\n    },\r\n]","/**\r\n * initialize global funcs in the sandbox\r\n * \r\n * (обработчики событий, назначенных в атрибутах, должны быть глобальными. Назначаем их глобальными здесь)\r\n * \r\n * @param {*} code \r\n * @returns \r\n */\r\nexport function generateGlobalInintializer(code) {\r\n\r\n    let globalInit = (code.match(/function ([\\w\\d_]+)\\s?\\(/gm) || [])\r\n        .map(it => it.split(' ')[1].replace('(', '').trim())\r\n        .map(it => 'globalThis.' + it + ' = ' + it).join(';\\n');\r\n\r\n    return globalInit;\r\n}\r\n\r\n\r\nexport const isPaired = (/** @type {string} */ tag) => !~['link'].indexOf(tag);","export const html = (/** @type {ReadonlyArray<string>} */ text, /** @type {any[]} */ ...args) => text.reduce((p, n, i) => p + args[i - 1] + n);","//@ts-check\r\n\r\nimport { html } from \"./../utils/linter\";\r\n\r\n\r\n// HTMLElement\r\nexport class ChoiceMenu extends HTMLElement {\r\n\r\n    itemStyle = ' \\\r\n        color: #aaa; \\\r\n        background-color: #444; \\\r\n        padding: 0.1em 1em 0.1em 2em; \\\r\n        margin-top: 1px; \\\r\n        text-align: right; \\\r\n        position: relative; '\r\n\r\n\r\n    /** selected element\r\n     * @type {HTMLElement}\r\n     */\r\n    selectedElement = null;\r\n\r\n    /** checked mark // only for external slot //\r\n     * @type {HTMLElement}\r\n     */\r\n    checkedElement = null;\r\n\r\n    /** ul\r\n     * @type {HTMLUListElement}\r\n     */\r\n    rootElement = null;\r\n\r\n    /** selected info\r\n     * @type {{id: string, metaId: string, value: string}}\r\n     */\r\n    checkInfo = null;\r\n\r\n    /// \r\n    //@ts-ignore\r\n    itemInitialize = (/** @type {HTMLLIElement} */ el) => ((el.onclick = (/** @type {Event} */ e) => this.selectedChanged(e)), el.style = this.itemStyle)\r\n\r\n    // get rootElement() { return this._rootElement; };\r\n    // set rootElement(v) {\r\n    //     console.log(v);\r\n    //     this._rootElement = v;\r\n    // }\r\n\r\n    \r\n    /** \r\n     * @deprecated\r\n     * @type number\r\n     */\r\n    // @ts-ignore    \r\n    get selectedIndex() {\r\n        let index = [].slice.call(this.rootElement.querySelectorAll('li')).indexOf(this.rootElement.querySelector('.selected'));\r\n        return index;\r\n    };\r\n    \r\n\r\n    /**\r\n     * @type string\r\n     */\r\n    // @ts-ignore\r\n    get selectedItem() {\r\n        //@ts-ignore\r\n        // return (this.rootElement.querySelector('.selected') || {}).innerText\r\n        return this.selectedElement.innerText;\r\n    };\r\n\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        /// base vars\r\n\r\n        //@ts-ignore\r\n        const rootElement = document.getElementById('choice-menu').content.cloneNode(true);\r\n        const shadowRoot = this.attachShadow({ mode: 'open' }).appendChild(rootElement);\r\n\r\n\r\n        // tactic vars\r\n\r\n        //\r\n        let menuElement = this.rootElement = this.shadowRoot.querySelector('ul');\r\n\r\n\r\n        // initialization event\r\n        const self = this; this.shadowRoot.addEventListener(\"slotchange\", function (event) {\r\n            //@ts-ignore\r\n            [menuElement] = [self.rootElement] = event.target.assignedElements();\r\n            self.checkedElement = self.shadowRoot.querySelector('.checked');\r\n            [].slice.call(self.rootElement.querySelectorAll('li')).forEach(self.itemInitialize);\r\n        });\r\n\r\n\r\n        // other events:                    \r\n        this.addEventListener('opened', () => this.pickItem(this.selectedElement))\r\n        this.addEventListener('click', this.visibleChanged);\r\n\r\n\r\n        /// only default slot:\r\n        this.rootElement.addEventListener('click', this.selectedChanged)\r\n    }\r\n\r\n\r\n    ///\r\n    visibleChanged() {\r\n\r\n        const self = this;\r\n        const opened = this.rootElement.classList.contains('active');\r\n\r\n        setTimeout(\r\n            () => {\r\n                self.rootElement.classList.toggle('active');\r\n                setTimeout(() => self.checkedElement && self.checkedElement.classList.toggle('active'), +!opened * 200)\r\n            },\r\n            +opened * 150\r\n        );\r\n\r\n        this.dispatchEvent(new CustomEvent(opened ? 'closed' : 'opened', { detail: null }))\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * @param {HTMLElement} element \r\n     */\r\n    pickItem(element) {\r\n        setTimeout(() => {\r\n            // console.log(this.checkedElement);\r\n\r\n            this.checkedElement.style.top = element.offsetTop + this.offsetHeight + 2 + 'px'\r\n            this.checkedElement.style.right = this.rootElement.offsetWidth - 20 + 'px';  // ? + (16 * 4)  \r\n        })\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @param {Event} event\r\n     */\r\n    selectedChanged(event) {\r\n        //@ts-expect-error\r\n        if (event.target.tagName === 'li'.toUpperCase()) {\r\n            \r\n            (this.selectedElement || (this.selectedElement = this.rootElement.querySelector('.selected'))) && this.selectedElement.classList.remove('selected');\r\n            //@ts-expect-error\r\n            (this.selectedElement = event.target).classList.add('selected');\r\n\r\n            //@ts-expect-error\r\n            this.checkedElement && this.pickItem(event.target)\r\n\r\n            this.dispatchEvent(new CustomEvent(\"selected_changed\", {\r\n                detail: this.checkInfo = {\r\n                    //@ts-expect-error\r\n                    id: event.target.id,\r\n                    //@ts-expect-error\r\n                    metaId: event.target.dataset.id,\r\n                    //@ts-expect-error\r\n                    value: event.target.innerText,\r\n                }\r\n            }))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * static constructor\r\n     */\r\n    static __contructor = (function () {\r\n        \r\n        document.body.insertAdjacentHTML('afterbegin', html`\r\n            <template id=\"choice-menu\">\r\n                <style>\r\n                    /* slotted need be styled inline */\r\n                    ::slotted(li),\r\n                    li {                \r\n                        color: white;\r\n                        background-color: #666;\r\n                        padding: 0.1em 1em 0.1em 2em;\r\n                        margin-top: 1px;\r\n                        position: relative;\r\n                    }\r\n\r\n                    ::slotted(ul), ul{\r\n                        margin: 0;\r\n                        padding-left: 0;\r\n                        position: absolute;\r\n                        top: 100%;\r\n                        right: .1em;\r\n                        width: max-content;\r\n                        list-style-type: none;\r\n                        transition: .3s;\r\n                        /* display: none; */\r\n                        \r\n                        overflow: hidden;\r\n                        height: 0;\r\n                    }\r\n\r\n                    /* стили применяемые к самому  my-paragraph*/\r\n                    :host {\r\n                        margin: 0em;\r\n                        /* margin-right: 2em; */\r\n                        position: relative;\r\n                    }\r\n\r\n                    ::slotted(.active), .active{\r\n                        /*display: block !important;*/\r\n\r\n                        height: 6em;                        \r\n                        display: block !important;\r\n                    }\r\n\r\n                    .selected::after, .checked{\r\n                        content: '';\r\n                        background: url(/static/images/check_mark.svg) no-repeat;\r\n                        background-size: contain;\r\n                        width: 1em;\r\n                        height: 2em;\r\n                        position: absolute;\r\n                        left: .5em;\r\n                        top: 0.15em;\r\n                    }\r\n\r\n                    .checked{\r\n                        left: auto;\r\n                        /* opacity: 0; */\r\n                        /* transition: opacity .3s ease .3s; */\r\n                        display: none; \r\n                        z-index: 5;\r\n                    }\r\n\r\n                </style>\r\n\r\n                <!-- <slot name=\"text\">My default text</slot> -->\r\n                <div class=\"checked\"></div>\r\n                <slot>\r\n                    <ul>\r\n                        <li class=\"selected\">item 1</li>\r\n                        <li>item 2</li>\r\n                    </ul>\r\n                </slot>\r\n\r\n            </template>\r\n        `);\r\n\r\n    })()\r\n\r\n}\r\n\r\n\r\n","export const modes = [\r\n    'html',\r\n    'css',\r\n    'javascript',\r\n    // 'typescript',\r\n]","// @ts-check\r\n\r\nimport { babelCompiler, compilers } from \"./features/compiler\";\r\nimport { generateGlobalInintializer, isPaired } from \"./utils/page_generator\";\r\nimport { commonStorage, getLangMode } from './utils/utils';\r\n\r\n// TODO REMOVE:\r\nimport { ChoiceMenu } from \"./ui/ChoiceMenu\";\r\nimport { modes as baseModes } from \"./features/base\";\r\n\r\n\r\nexport { compilers, babelCompiler };\r\n\r\n/**\r\n * @type {{editors: any[], iframe: any, curUrl: any, fileStorage: object, modes?: [object?, object?, object?], onfilerename?: Function, onfileRemove?: (name: string) => void}}\r\n */\r\nexport const playgroundObject = {\r\n    editors: [],\r\n    iframe: null,\r\n    curUrl: null,\r\n    fileStorage: { _active: 0 },\r\n    modes: null,\r\n    onfilerename: null,\r\n    onfileRemove: null\r\n}\r\n\r\n\r\n/**\r\n * @param {{ [x: string]: string; }} [attrs]\r\n */\r\nfunction createHtml({ body, style, script, link }, attrs) {\r\n\r\n    // globalThis.__debug && console.log(arguments);\r\n\r\n    const htmlStruct = {\r\n        html: {\r\n            head: {\r\n                style,\r\n                script,\r\n                link\r\n            },\r\n            body\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {{ [x: string]: any; html?: { head: { [x: string]: string; script: string; }; body: any; }; }} nodeStruct\r\n     */\r\n    function nodeCreate(nodeStruct) {\r\n\r\n        let html = '';\r\n        for (const key in nodeStruct) {\r\n\r\n            let _attrs = attrs[key] || '';\r\n            let content = typeof nodeStruct[key] === typeof nodeStruct\r\n                ? nodeCreate(nodeStruct[key])\r\n                : (nodeStruct[key] || '');\r\n\r\n            html += content !== null\r\n                ? ('<' + key + _attrs + '>' + content + '</' + key + '>')\r\n                : ('<' + key + _attrs + '/>');\r\n\r\n        }\r\n        return html;\r\n    }\r\n\r\n    return nodeCreate(htmlStruct);\r\n}\r\n\r\n\r\n/**\r\n * \r\n * TODO: option {simplestBundler, fileStore}\r\n * \r\n * @param {string} [prevUrl] - предыдущий URL для освобождения\r\n * @param {string[]} [additionalScripts] - дополнительные скрипты, которые будут добавлены на новую страницу (react, vue, preact...)\r\n * @param {string} [scriptType] - атрибут тега скрипт, который будет добавлен в к тегу script на созданной странице (type=)\r\n * @param {{onload: Function}} [options] - onload callback\r\n * @returns {[HTMLElement, string]}\r\n */\r\nexport function createPage(prevUrl, additionalScripts, scriptType, options) {\r\n\r\n    // alert(99)\r\n    if ((playgroundObject.fileStorage || window['fileStore']) && playgroundObject.editors) {\r\n        const fileStorage = playgroundObject.fileStorage || window['fileStore'];\r\n        let activeTab = document.querySelector('.tabs .tab.active');\r\n        // update current tab content:\r\n\r\n        if (fileStorage) {\r\n            fileStorage[fileStorage.innerText] = playgroundObject.editors[2].getValue()\r\n        }        \r\n    }\r\n    \r\n    let _fs = (playgroundObject.fileStorage || window['fileStore'] || {});\r\n    let appCode = _fs['app.js'] || _fs['app.ts'] || playgroundObject.fileStorage[undefined + ''];\r\n    // globalThis.__debug && console.log('appCode');\r\n\r\n\r\n    const langMode = getLangMode(appCode);\r\n    if (langMode) {\r\n\r\n        var currentLang = playgroundObject.modes && playgroundObject.modes[2] && playgroundObject.modes[2][langMode];\r\n\r\n        \r\n        if (currentLang && currentLang.src && currentLang.target === 'self') {\r\n\r\n            // currentLang.target === 'self'        /// script ожидает загрузки скрипта на основную страницу\r\n            \r\n            let scriptID = currentLang.src.split('/').pop().split('.').shift();\r\n            let originScript = document.getElementById(scriptID)\r\n            if (!originScript) {\r\n                originScript = document.createElement('script');\r\n                //@ts-ignore\r\n                originScript.src = currentLang.src;\r\n                originScript.id = scriptID;\r\n                originScript.onload = () => {\r\n\r\n                    // createPage(prevUrl, additionalScripts, scriptType, options);\r\n                    waiting.parentElement.removeChild(waiting);\r\n                    if (options && options.onload) {\r\n                        let frameInfo = createPage(prevUrl, additionalScripts, scriptType);\r\n                        options.onload(...frameInfo);\r\n                    }\r\n                }\r\n                document.head.appendChild(originScript);\r\n                let waiting = document.querySelector('.view').appendChild(document.createElement('div'))\r\n                waiting.innerText = 'Ожидание...'\r\n                waiting.id = 'view__waiting';                \r\n                \r\n                if (options && options.onload) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    let buildJS = (/** @type {string} */ code) => {        \r\n\r\n        // convert to js:   \r\n\r\n        code = buildAndTranspile(code, currentLang);\r\n\r\n        // \r\n        let globalReinitializer = generateGlobalInintializer(code);\r\n\r\n        code = 'window.addEventListener(\"' + (scriptType ? 'load' : 'DOMContentLoaded') + '\", function(){' + code + '\\n\\n' + globalReinitializer + '\\n});';\r\n\r\n        // customLOG\r\n        const terminalJar = document.querySelector('.console .lines');\r\n        \r\n        if (terminalJar) {\r\n\r\n            terminalJar.innerHTML = '';\r\n\r\n            function loclog(/** @type {string} */ value) {\r\n\r\n                window.parent.postMessage(\r\n                    // { value: typeof value === 'object' ? JSON.stringify(value) : value, type: typeof value },\r\n                    { value: String.fromCharCode(8250) + ' ' + value, type: typeof value },\r\n                    '*'\r\n                );\r\n                console.log([].slice.call(arguments).join());\r\n            }\r\n\r\n            function onmessage(event) {\r\n                if (typeof event.data == 'string') {\r\n\r\n                    let data = {type: 'string'}\r\n                    try {\r\n                        data.value = globalThis.eval(event.data);\r\n                    }\r\n                    catch (e) {\r\n                        data.value = data.error = '> ' + e.stack.split(':').shift() + ': ' + e.message;\r\n                    }\r\n\r\n                    if (typeof data.value === 'object') {\r\n                        if (data.value === null) data.value += '';                        \r\n                        else if (~data.value.toString().indexOf('HTML')) data.value = data.value.toString()\r\n                        else {\r\n                            data.value = JSON.stringify(data.value)\r\n                        }\r\n                    }\r\n                    console.log(data);\r\n                    window.parent.postMessage(data, '*')\r\n                }\r\n            }\r\n\r\n            const onmessageFunc = \"window.addEventListener('message', \" + onmessage.toString() + \");\"\r\n\r\n            code = '\\n' + loclog.toString() + '\\n' + onmessageFunc + '\\n\\n' + code.replace(/console\\.(log|warn)/g, 'loclog');\r\n        }        \r\n\r\n        return code;\r\n    }\r\n\r\n\r\n    // при concat все равно скопируется\r\n    // additionalScripts = additionalScripts.slice()\r\n    \r\n    \r\n    const editors = playgroundObject.editors;\r\n    const baseTags = ['body', 'style', 'script'];\r\n    const attrs = {\r\n        script: scriptType\r\n    }\r\n\r\n    // compilerSubModes дополняем:\r\n    if (playgroundObject.modes && playgroundObject.modes.length) playgroundObject.editors.forEach((editor, i) => {\r\n\r\n        /**\r\n         * @type ChoiceMenu\r\n         */\r\n        let modeMenu = editor.container.querySelector('choice-menu');\r\n        if (modeMenu) {\r\n            /**\r\n             * @type {{src: string|string[], target?: {tag: string, attributes: string, inside?: true}}}\r\n             */\r\n            let actualMode = playgroundObject.modes[i][modeMenu.selectedElement.innerText]\r\n            if (actualMode) {                \r\n                // additionalScripts = (additionalScripts || []).concat(typeof actualMode.src === 'string' ? [actualMode.src] : actualMode.src);\r\n                [].slice.call(typeof actualMode.src === 'string' ? [actualMode.src] : actualMode.src).forEach(el => additionalScripts.push(el));\r\n                // дополнительные скрипты. В частности less\r\n                window['__debug'] && console.log(additionalScripts);\r\n            }\r\n            \r\n            if (actualMode && actualMode.target) {\r\n                                                \r\n                /// possibility change style tag to link tag:\r\n                if (actualMode.target.tag) baseTags[i] = actualMode.target.tag;\r\n\r\n                if (actualMode.target.inside) {\r\n\r\n                    // here constructs tags that will involve right to iframe:\r\n                    \r\n                    let blob = new Blob([editors[i].getValue()], { type: 'text/' + baseModes[i] });\r\n                    let link = URL.createObjectURL(blob);\r\n                    // actualMode.target.attributes = actualMode.target.attributes.replace('{}', link)\r\n                    actualMode.target.attributes = actualMode.target.attributes.replace(/href\\=\"[\\:\\w\\d-\\{\\}/\\.]+\"/, 'href=\"' + link + '\"')\r\n                    // window['__debug'] && console.log(baseModes[i]);\r\n                    window['__debug'] && console.log(link);\r\n                    // window['__debug'] && console.log(actualMode.target);\r\n                }\r\n                if (actualMode.target.attributes) attrs[baseTags[i]] = actualMode.target.attributes;\r\n            }\r\n        }\r\n    })\r\n\r\n    \r\n    /// TODO? @import 'style.css' to style html tag from link file?\r\n    \r\n    let htmlContent = baseTags.reduce((acc, el, i, arr) => (\r\n        (\r\n            acc[el] = i < 2\r\n                ? isPaired(el) ? editors[i].getValue() : null\r\n                : buildJS(appCode || editors[i].getValue())\r\n        ), acc),\r\n        {}\r\n    );    \r\n\r\n    let optionalScripts = ''\r\n    if (additionalScripts && additionalScripts.length) {\r\n        for (let i = 0; i < additionalScripts.length; i++) {\r\n            // htmlContent['body'] += '<script src=\"' + additionalScripts[i] + '\"></script>';\r\n            optionalScripts += '<script src=\"' + additionalScripts[i] + '\"></script>';\r\n        }\r\n    }    \r\n    \r\n    window['__debug'] && console.log('htmlContent', htmlContent);\r\n\r\n    let html = createHtml(htmlContent, attrs);\r\n\r\n    globalThis.__debug && console.log(optionalScripts);\r\n    html = html.replace('</head>', optionalScripts + '</head>');\r\n    html = html.replace('<head>', '<head><meta charset=\"UTF-8\">');\r\n\r\n    let file = new Blob([html], { type: 'text/html' });\r\n\r\n    prevUrl && URL.revokeObjectURL(prevUrl);\r\n    let url = URL.createObjectURL(file);\r\n\r\n    let view = document.querySelector('.view');\r\n    playgroundObject.iframe && (playgroundObject.iframe.parentElement === view) && view.removeChild(playgroundObject.iframe);\r\n    // view.innerHTML = '';    \r\n\r\n    let frame = document.createElement('iframe');\r\n    frame.sandbox.add('allow-scripts')\r\n    frame.sandbox.add('allow-modals')\r\n    // frame.sandbox.add('allow-same-origin')\r\n    frame.src = url;\r\n    view.appendChild(frame)\r\n\r\n    return [frame, url]\r\n}\r\n\r\n\r\n/**\r\n * @param {string} code\r\n * @param {{ compileFunc: (arg0: string) => string; }} currentLang\r\n */\r\nfunction buildAndTranspile(code, currentLang) {\r\n    if (window['simplestBundler']) {\r\n        code = window['simplestBundler'].default(code, playgroundObject.fileStorage || window['fileStore']);\r\n        globalThis.__debug && console.log('build...');\r\n    }\r\n    else {\r\n        console.warn('bundler is absent');\r\n        // alert('Warn/ look logs')\r\n    }\r\n\r\n    // ts transpilation:\r\n    if (currentLang && currentLang.compileFunc) {\r\n        code = currentLang.compileFunc(code);\r\n    }\r\n    return code;\r\n}\r\n\r\n/**\r\n * // obsolete @ param {(url: string) => [HTMLIFrameElement, string]} [createPageFunc]\r\n * @param {boolean} jsxMode ///! param {number} compilerMode\r\n * @param {string[]} compilerModes - list of script libs to attach to generated page\r\n *\r\n * TODO: options: {storage (localStorage|sessionStorage), fileStore}\r\n * @param {boolean|undefined} [less] - less compile mode (Not implemented yet. TODO: via postMessage)\r\n */\r\nexport function webCompile(jsxMode, compilerModes, less) {\r\n\r\n    globalThis.__debug && console.log('compile');\r\n\r\n    // [iframe, curUrl] = createPage(curUrl);\r\n    // globalThis.__debug && console.log(iframe);\r\n\r\n    \r\n\r\n    let iframe = playgroundObject.iframe,\r\n        editors = playgroundObject.editors;\r\n\r\n    const fileStorage = playgroundObject.fileStorage || window['fileStore'];\r\n    //@ts-ignore\r\n    if (Object.keys(fileStorage || {}).length) {\r\n        let activeTab = document.querySelector('.tabs .tab.active');\r\n        //@ts-ignore\r\n        if (activeTab) fileStorage[activeTab.innerText] = editors[2].getValue()\r\n        // else {\r\n        //     fileStorage[undefined + ''] = editors[2].getValue()\r\n        // }\r\n    }\r\n\r\n    if (iframe.contentDocument && less) {\r\n        \r\n        /**\r\n         * attantion: because from deleted scripts, working handlers may remain on the page, which will spoil the picture \r\n         * (it may be safe to change styles only or for frameworks that completely overwrite html). With a full html record , it is quite an option\r\n         */\r\n\r\n        iframe.contentDocument.body.innerHTML = editors[0].getValue()\r\n        iframe.contentDocument.head.querySelector('style').innerHTML = editors[1].getValue()\r\n\r\n        /////// remove last script:\r\n\r\n        let lastScript = [].slice.call(iframe.contentDocument.querySelectorAll('script')).pop();\r\n        lastScript && lastScript.parentElement.removeChild(lastScript);\r\n\r\n        //////// \r\n\r\n        // let lastScripts = iframe.contentDocument.querySelectorAll('script');\r\n        // lastScripts && lastScripts.length && Array.prototype.slice.call(lastScripts).forEach((/** @type {{ parentElement: { removeChild: (arg: any) => void; }; }} */ element) =>\r\n        // {\r\n        //     element.parentElement.removeChild(element);\r\n        // });\r\n        \r\n        /////////\r\n        \r\n        // [].slice.call(document.querySelector('iframe').contentDocument.getElementsByTagName('script')).pop()\r\n\r\n        let script = iframe.contentDocument.createElement('script');\r\n        \r\n        globalThis.__debug && console.log('less compilation')\r\n        globalThis.__debug && console.log(jsxMode)\r\n        globalThis.__debug && console.log(compilerModes);\r\n\r\n        if (jsxMode) {\r\n            \r\n            // add additional scripts:\r\n\r\n            // for (let i = 0; i < compilerMode.length; i++) {\r\n            //     const link = compilerMode[i];\r\n\r\n            //     let jsxCompiler = iframe.contentDocument.createElement('script');\r\n            //     jsxCompiler.src = link;\r\n            //     iframe.contentDocument.body.appendChild(jsxCompiler);\r\n            // }\r\n\r\n            script.type = \"text/babel\";\r\n        }\r\n\r\n        let code = playgroundObject.fileStorage['app.js'] || playgroundObject.fileStorage['app.ts'] || editors[2].getValue();\r\n\r\n        const currentLang = playgroundObject.modes && playgroundObject.modes[2] && playgroundObject.modes[2][getLang()];\r\n        code = buildAndTranspile(code, currentLang);\r\n\r\n        let globalReinitializer = generateGlobalInintializer(code)\r\n\r\n        script.innerHTML = '(function(){' + code + ';\\n\\n' + globalReinitializer + '\\n})()';\r\n        iframe.contentDocument.body.appendChild(script)\r\n        // iframe.contentDocument.head.querySelector('script').innerHTML = editors[2].getValue()\r\n    }\r\n    else {\r\n        // globalThis.__debug && console.log(compilerMode);\r\n        // globalThis.__debug && console.log(Object.values(compilers)[compilerMode]);\r\n        // let [iframe, curUrl] = createPage(playgroundObject.curUrl, Object.values(compilers)[compilerMode], jsxMode ? babelCompiler.mode : undefined);\r\n        let [iframe, curUrl] = createPage(playgroundObject.curUrl, compilerModes, jsxMode ? babelCompiler.mode : undefined);\r\n        playgroundObject.iframe = iframe;\r\n        playgroundObject.curUrl = curUrl;\r\n    }\r\n\r\n\r\n\r\n\r\n    let compiler = Number.parseInt((commonStorage || localStorage).getItem('mode') || '0');\r\n\r\n    // just sandbox feature:\r\n    (commonStorage || localStorage).setItem(compiler + '__html', editors[0].getValue());\r\n    (commonStorage || localStorage).setItem(compiler + '__css', editors[1].getValue());\r\n    (commonStorage || localStorage).setItem(compiler + '__javascript', editors[2].getValue());\r\n    \r\n\r\n\r\n    let modulesStore = {};\r\n\r\n    console.log('save modules...')\r\n\r\n    if (fileStorage && Object.keys(fileStorage).length > 1) {\r\n        \r\n        for (let i = 0; i < Object.keys(fileStorage).length; i++) {\r\n            const fileName = Object.keys(fileStorage)[i];\r\n            if (fileName.startsWith('_')) continue;\r\n            modulesStore[fileName] = fileStorage[fileName];\r\n        }\r\n\r\n        // js multitabs:\r\n        (commonStorage || localStorage).setItem('_modules', JSON.stringify(modulesStore));\r\n        globalThis.__debug && console.log('save modules...');\r\n    }\r\n\r\n    // document.getElementById('compiler_mode')\r\n}\r\n\r\n\r\n\r\nfunction getLang() {\r\n    let fs = (playgroundObject.fileStorage || window['fileStore'] || {});\r\n    let appCode = fs['app.js'] || fs['app.ts'] || playgroundObject.fileStorage[undefined + ''];\r\n    const langMode = getLangMode(appCode);\r\n    return langMode;\r\n}\r\n\r\n","//@ts-check\r\n\r\nimport { playgroundObject } from \"../pageBuilder\";\r\n\r\nexport const commonStorage = sessionStorage;\r\n\r\n/**\r\n * @param {{ (): number; (): any; }} func\r\n * @param {number} delay\r\n */\r\nexport function debounce(func, delay) {\r\n    \r\n    let inAwaiting = false;\r\n\r\n    return function ()\r\n    {\r\n        if (!inAwaiting) {\r\n\r\n            let result = func();\r\n\r\n            inAwaiting = true;\r\n            setTimeout(() => inAwaiting = false, delay);\r\n\r\n            return result;\r\n        }\r\n    };\r\n}\r\n\r\n\r\n\r\n/**\r\n * extracts lang mode from code text\r\n * \r\n * @param {string} code\r\n * @returns {string|null}\r\n */\r\nexport function getLangMode(code)\r\n{\r\n    let langModeMatch = code.match(/\\/\\* ([\\w \\n]+) \\*\\//);\r\n\r\n    return langModeMatch\r\n        ? langModeMatch.pop()\r\n        : null;\r\n}\r\n\r\n\r\n/**\r\n * @param {string} prevName\r\n * @param {string} fullname\r\n * @param {{ find: (arg0: string) => any; getSession: () => string; }} editor\r\n */\r\nfunction renameOccurrences(prevName, fullname, editor) {\r\n    let fileStore = playgroundObject.fileStorage\r\n    fileStore[fullname] = fileStore[prevName];\r\n    delete fileStore[prevName];\r\n\r\n    for (let file in playgroundObject.fileStorage) {\r\n        if (typeof playgroundObject.fileStorage[file] === 'string') {\r\n            playgroundObject.fileStorage[file] = playgroundObject.fileStorage[file].replace(prevName, fullname);\r\n        }\r\n    }\r\n\r\n    let pos = editor.find(prevName + \"'\")\r\n    pos && editor.getSession().replace(pos, fullname + \"'\")\r\n}\r\n","// @ts-check\r\n\r\nimport { createPage, playgroundObject } from \"../pageBuilder\";\r\n\r\n\r\n/**\r\n * @param {{currentTarget: any;}} event\r\n * @param {string[]} [additionalScripts]\r\n * @param {string} [scriptType]\r\n */\r\nexport function expand(event, additionalScripts, scriptType) {\r\n\r\n    let [iframe, curUrl] = createPage(playgroundObject.curUrl, additionalScripts, scriptType);\r\n\r\n    playgroundObject.iframe = iframe;\r\n    playgroundObject.curUrl = curUrl;\r\n\r\n    const view = document.querySelector('.view');\r\n    // const view = event.currentTarget.parentElement;\r\n    // let iframe = view.querySelector('iframe');\r\n    let wrapper = document.querySelector('.expanded')\r\n\r\n    // @ts-ignore\r\n    if (wrapper && wrapper.style.display == 'none') {\r\n        // @ts-ignore\r\n        wrapper.style.display = 'block';\r\n        wrapper.innerHTML = '';\r\n    }\r\n    else if(!wrapper) {\r\n        wrapper = document.body.appendChild(document.createElement('div'));\r\n        wrapper.className = 'expanded';\r\n        // wrapper.tabIndex = '0';\r\n        // wrapper.onkeydown = function escape(event) { }        \r\n    }\r\n    // else if (wrapper) wrapper.innerHTML = '';\r\n    // wrapper.appendChild(iframe.cloneNode(true));\r\n    \r\n    wrapper.appendChild(iframe);    \r\n\r\n    let collapseButton = wrapper.appendChild(event.currentTarget);\r\n    collapseButton.classList.add('down');\r\n    collapseButton.dataset.title = 'Collapse'\r\n\r\n    collapseButton.onclick = function (event) {\r\n\r\n        view.appendChild(iframe);\r\n        view.appendChild(collapseButton);\r\n\r\n        collapseButton.classList.remove('down');\r\n        collapseButton.dataset.title = 'Expand'\r\n        collapseButton.onclick = expand;\r\n        // @ts-ignore\r\n        wrapper.style.display = 'none';\r\n    }\r\n}\r\n","// https://stackoverflow.com/questions/58377763/how-do-i-programmatically-add-a-snippet-in-ace-editor\r\n// https://prog.world/implementing-code-completion-in-ace-editor/\r\n\r\n//@ts-check\r\n\r\n\r\n\r\nexport let domFuncs = {\r\n    style: null,\r\n    color: null,\r\n\r\n    // ReactDOM: {\r\n    //     desc: 'only for react lib namespace',\r\n    //     return: 'namespace'\r\n    // },\r\n    render: {\r\n        desc: 'render preact/react component to html DOM',\r\n        sign: {\r\n            'component': {\r\n                desc: 'react/preact component',\r\n                type: 'VNode<any>'\r\n            },\r\n            parent: {\r\n                desc: 'app root inside DOM tree',\r\n                type: 'HTMLElement'\r\n            }\r\n        },\r\n        return: 'HTMLElement'\r\n    },\r\n\r\n\r\n    useRef: {\r\n        desc: 'get a reference to a DOM node inside a functional components',\r\n        sign: {\r\n            initialValue: {\r\n                desc: 'initial value'\r\n            }\r\n        },\r\n        'return': 'Ref<T>'\r\n    },\r\n    useState: {\r\n        desc: 'assigns the starting state value, and returns an array of two elements',\r\n        sign: {\r\n            initialState: {\r\n                type: '<T>(initialState: T | (() => T))',\r\n                desc: 'initial state'\r\n            }\r\n        },\r\n        'return': '[T, StateUpdater<T>]'\r\n    },\r\n    useEffect: {\r\n        desc: '',\r\n        sign: {\r\n            effect: {\r\n                type: 'EffectCallback',\r\n                desc: 'callback function'\r\n            },\r\n            inputs: {\r\n                type: 'Inputs?',\r\n                desc: ''\r\n            }\r\n        }\r\n    },\r\n\r\n\r\n\r\n    // Array and string methods: \r\n\r\n    indexOf: '',\r\n    from: '',\r\n    slice: '',\r\n\r\n\r\n    // snippets:\r\n\r\n    qf: {\r\n        desc: '',\r\n        value: '[].slice.call(document.querySelector(${1:selector})).forEach((${2:elem}) => {\\n\\t${3}\\n})'\r\n    },\r\n    qm: {\r\n        desc: '',\r\n        value: '[].slice.call(document.querySelector(${1:selector})).map(elem => {\\n\\t${2}\\n})'\r\n    },\r\n\r\n    // qff: {\r\n    //     desc: '',\r\n    //     value: '[].slice.call(document.querySelector(${1:selector}).filter(elem => elem.${2:innerText} == ${3}).forEach(elem => {\\n\\t${4}\\n})'\r\n    // },\r\n    // qfm: {\r\n    //     desc: '',\r\n    //     value: '[].slice.call(document.querySelector(${1:selector}).filter(elem => elem.${2}).map(elem => {\\n\\t${3}\\n})'\r\n    // },\r\n\r\n    fore: {\r\n        desc: 'forEach',\r\n        origin: 'forEach',\r\n        value: 'forEach((${1:elem}, ${2:i}, ${3:array}) => {\\n\\t${4}\\n})',\r\n        sign: {\r\n            callback: { type: ' (elem, i, array) => void', desc: 'функция обратного вызова' },\r\n            context: { type: ' this?', desc: 'контекст' }\r\n        }\r\n    },\r\n    log: {\r\n        desc: 'console.log',\r\n        value: 'console.log(${1})',\r\n        sign: {\r\n            message: {\r\n                type: 'string',\r\n            }\r\n        }\r\n    },\r\n\r\n\r\n    // DOM:\r\n\r\n    target: null,\r\n    classList: null,\r\n    offsetHeight: null,\r\n    offsetWidth: null,\r\n    getComputedStyle: '',\r\n\r\n    innerHTML: null,\r\n    innerText: null,\r\n\r\n    appendChild: '',\r\n    insertBefore: '',\r\n    createElement: '',\r\n\r\n    preventDefault: '',                                         //// - event\r\n    key: '',                                                    //// - event\r\n\r\n    closest: '',\r\n    \r\n    getElementById: {\r\n        desc: '',  //  'Найти элемент по его ID',\r\n        'return': 'HTMLElement?'\r\n    },\r\n    \r\n    querySelectorAll: '',\r\n    querySelector: {\r\n        desc: 'get element by selector',\r\n        sign: {\r\n            'selector': {\r\n                type: 'string',\r\n                desc: 'element selector'\r\n            }\r\n        },\r\n        'return': 'HTMLElement'\r\n    },\r\n\r\n    // Events: \r\n\r\n    addEventListener: {\r\n        desc: '',\r\n        sign: {\r\n            'selector': {\r\n                type: 'string',\r\n                desc: 'element selector'\r\n            }\r\n        },\r\n    },\r\n\r\n    onload: '',\r\n    onclick: '',\r\n    oninput: '',\r\n    onkeydown: '',\r\n    onchange: '',\r\n\r\n    onmousedown: '',\r\n    onmousemove: '',\r\n    onmouseover: '',\r\n    onmouseout: '',\r\n}\r\n\r\n\r\nlet wordList = Object.keys(domFuncs);\r\n\r\nexport let keyWords = wordList.map(\r\n    function (word) {\r\n        const metaInfo = domFuncs[word];\r\n        return {\r\n            caption: word,\r\n            value: word + (undefined ? '()' : ''),  // для методов без параметров (таких-то и не могу даже вспомнить)\r\n            // meta: \"local\",\r\n            // meta: \"static\",\r\n\r\n            // snippet: 'This2(${1})',\r\n\r\n            // (metaInfo && metaInfo.sign) - только для описанных сигнатурой\r\n            snippet: metaInfo !== null ? (metaInfo.value || (word.startsWith('on') ? (word + ' = e => {${1}}') : ((metaInfo.value || word) + '(${1})'))) : undefined,\r\n\r\n            type: (metaInfo && metaInfo.sign) ? \"snippet\" : 'static',\r\n            meta: (metaInfo !== null && !word.startsWith('on')) ? (metaInfo.value ? 'function' : 'function') : 'prop',\r\n\r\n            // completer: {\r\n            //     insertMatch: function (editor, data) {\r\n            //         editor.completer.insertMatch({ value: data.value })\r\n            //     }\r\n            // }\r\n\r\n            // inputParameters: { 1: '?' },\r\n        };\r\n    }\r\n)\r\n\r\n\r\n\r\n/**\r\n * @param {{\r\n *  completers: { \r\n *      getCompletions: (editor: any, session: any, pos: any, prefix: any, callback: any) => void;\r\n *      getDocTooltip: (item: {docHTML: string;caption: string;}) => void;\r\n *   }[];\r\n * }} editor : ace editor instanse\r\n * @param {{ hint?: {desc: string, origin?: string, sign: {[x: string]: {type: string, description: string}}}; name: string; template?: string; meta?: 'function'|'property'; }} keyWordInfo\r\n */\r\nexport function autocompleteExpand(editor, keyWordInfo) {\r\n\r\n    let hint = keyWordInfo.hint;\r\n    \r\n    editor.completers.push({\r\n        getCompletions: function (editor, session, pos, prefix, callback) {\r\n            // prefix !== '.' ? [] :\r\n            callback(null, [{\r\n                caption: keyWordInfo.name,\r\n                value: keyWordInfo.name,\r\n                snippet: keyWordInfo.template,\r\n                meta: keyWordInfo.meta || '',\r\n            }]);\r\n        },\r\n        getDocTooltip: function (/** @type {{ docHTML: string; caption: string; }} */ item) {\r\n            \r\n            if (hint) {\r\n                let args = Object.keys(hint.sign || {}).map(arg => arg + ': ' + hint.sign[arg].type).join(', ');\r\n                item.docHTML = '<h5>' + (hint.origin || item.caption) + '(' + args + ') : ' + hint['return'] + '</h5><hr>' + '<p>' + hint.desc + '</p>'\r\n                let argsDesc = ''\r\n                for (const key in hint.sign) {\r\n                    argsDesc += '<li><b>' + key + ':' + (hint.sign[key].type || 'any') + '</b> - ' + hint.sign[key].description\r\n                }\r\n                item.docHTML += '<ul>' + argsDesc + '</ul>'\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//! не используется !//\r\n\r\n\r\n\r\n// динамическое добавление сниппетов:\r\n\r\n\r\n// var ace = window['ace'];\r\n\r\n// export const registerSnippets = function (editor, session, mode, snippetText) {\r\n//     editor.setOptions({\r\n//         enableBasicAutocompletion: true,\r\n//         enableSnippets: true,\r\n//     })\r\n\r\n//     var snippetManager = ace.require('ace/snippets').snippetManager\r\n\r\n//     var id = session.$mode.$id || ''\r\n//     var m = snippetManager.files[id]\r\n\r\n//     m.scope = mode\r\n//     m.snippetText = snippetText\r\n//     m.snippet = snippetManager.parseSnippetFile(snippetText, m.scope)\r\n\r\n//     snippetManager.register(m.snippet, m.scope)\r\n// }\r\n\r\n// export const createSnippets = snippets =>\r\n//     (Array.isArray(snippets) ? snippets : [snippets])\r\n//         .map(({ name, code }) =>\r\n//             [\r\n//                 'snippet ' + name,\r\n//                 code\r\n//                     .split('\\n')\r\n//                     .map(c => '\\t' + c)\r\n//                     .join('\\n'),\r\n//             ].join('\\n')\r\n//         )\r\n//         .join('\\n')","//@ts-check\r\n\r\nimport { playgroundObject } from \"../pageBuilder\";\r\nimport { autocompleteExpand, keyWords } from \"../utils/autocompletion\";\r\n\r\n\r\n\r\nconst menuPoints = {\r\n    'Удалить': (e) => {\r\n        if (confirm('Вы уверены, что хотите удалить файл `' + e.target.innerText + '`'))\r\n        {\r\n            playgroundObject.onfileRemove(e.target.innerText + '');\r\n            delete playgroundObject.fileStorage[e.target.innerText];\r\n            e.target.parentElement.removeChild(e.target);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n// var fileStore = { _active: 0 };\r\n\r\n/**\r\n * @param {{ file?: string; target: any; editors?: object[] }} event\r\n */\r\nexport function fileAttach(event) {\r\n\r\n    var fileStore = playgroundObject.fileStorage;\r\n\r\n    //! Проверяем имя файла на валидность:\r\n\r\n    var editors = event['editors'] || window['editors'];\r\n    var filename = event.file || prompt('Enter file name:');\r\n\r\n    if (!filename) return;\r\n\r\n    // console.log('__fileAttach');\r\n\r\n    let ext = (fileStore['app.ts'] || editors[2].session.getLine(0).match(/typescript/)) ? '.ts' : '.js';\r\n    let title = ~filename.indexOf('.') ? filename : (filename + ext);\r\n\r\n    if (!event.file && ~Object.keys(fileStore).indexOf(title)) {\r\n        alert('Файл с таким именем уже существует');\r\n        return;\r\n    }\r\n\r\n\r\n    let importSnippet = {\r\n        name: \"import { * } from './\" + title + \"'\",\r\n        template: \"import { ${1} } from './\" + title + \"'\"\r\n    }\r\n\r\n\r\n\r\n    let target = event.target;\r\n\r\n    //! Настройка переключения между табами:\r\n\r\n    let origTab = target.parentElement.querySelector('.tab.active') || target.parentElement.children[0];\r\n    \r\n    /**\r\n     * Rename existing file\r\n     * @param {MouseEvent} e \r\n     * @returns \r\n     */\r\n    origTab.ondblclick = function (/** @type {{ target: { innerText: string; }; }} */ e) {        \r\n\r\n        if (!playgroundObject.onfilerename) {\r\n            console.warn('Specify onfilerename callback argument to activate the feature!');\r\n            return;\r\n        }\r\n\r\n        const prevName = e.target.innerText;\r\n        if (prevName.match(/app\\.\\ws/)) {\r\n            return;\r\n        }\r\n\r\n        let fileInfo = prevName.split('.')\r\n        let filename = prompt('Enter new file name:', fileInfo[0])\r\n        if (filename === fileInfo[0]) return;\r\n        else if (!filename) {\r\n            alert('Имя файла должно содержать буквы (хотя бы одну)')\r\n            return;\r\n        }\r\n        else {\r\n            let fullname = [filename, fileInfo[1]].join('.')\r\n\r\n\r\n\r\n            if (!playgroundObject.onfilerename) {\r\n                renameOccurrences(prevName, fullname);\r\n                e.target.innerText = fullname;\r\n            }\r\n            else {\r\n                playgroundObject.onfilerename(e.target.innerText, fullname, () => {\r\n                    e.target.innerText = fullname;\r\n                    renameOccurrences(prevName, fullname)\r\n                });\r\n            }\r\n            \r\n            \r\n            /**\r\n             * \r\n             * @param {string} prevName \r\n             * @param {string} fullname \r\n             */\r\n            function renameOccurrences (prevName, fullname) {\r\n                fileStore = playgroundObject.fileStorage\r\n                fileStore[fullname] = fileStore[prevName];\r\n                delete fileStore[prevName];\r\n\r\n                for (let file in playgroundObject.fileStorage) {\r\n                    if (typeof playgroundObject.fileStorage[file] === 'string') {\r\n                        playgroundObject.fileStorage[file] = playgroundObject.fileStorage[file].replace(prevName, fullname);\r\n                    }\r\n                }\r\n\r\n                let pos = editors[2].find(prevName + \"'\")\r\n                pos && editors[2].getSession().replace(pos, fullname + \"'\")\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggle tabs\r\n     * @param {MouseEvent} ev\r\n     * @returns\r\n     */\r\n    origTab.onclick = origTab.onclick || function toggleTab (/** @type {{ target: { classList: { add: (arg0: string) => void; }; innerText: string | number; }; }} */ ev) {\r\n        let prevTab = document.querySelector('.tab.active');\r\n        if (prevTab) {\r\n\r\n            fileStore = playgroundObject.fileStorage;  // т.к. при смене языка мы можем переопределить playgroundObject.fileStorage = Object.assign...\r\n\r\n            const prevTabName = prevTab['innerText'];\r\n\r\n            prevTab.classList.toggle('active');\r\n\r\n            fileStore[prevTabName] = editors[2].getValue();\r\n            \r\n            const exports = fileStore[prevTabName].match(/export (function|const|let|class) (\\w+)/g) || [];\r\n            const defaultExport = fileStore[prevTabName].match(/export default function (\\w+)/);\r\n            \r\n            // atocomplete update:\r\n\r\n            exports.forEach((/** @type {string} */ ex) => {\r\n                let exprWords = ex.split(' ');\r\n                let caption = exprWords.pop();\r\n                let meta = exprWords.pop()\r\n                keyWords.push({\r\n                    caption,\r\n                    value: caption,\r\n                    meta,\r\n                    type: '',\r\n                    snippet: undefined // meta == 'function' ? (caption + '(${1})') : undefined\r\n                })\r\n            })\r\n\r\n\r\n            // extension changing:\r\n            // if (importSnippet.template.endsWith(\".ts\") && !fileStore['app.ts']) {\r\n            //     // autocomplete refactoring:                \r\n            //     importSnippet.name = importSnippet.template = importSnippet.template.replace(prevTabName + '\"', title + '\"');\r\n            // }\r\n\r\n\r\n\r\n\r\n            // let actualExt = prevTabName.split('.').pop();\r\n            // if (!title.endsWith(actualExt)) {\r\n                \r\n            //     // autocomplete refactoring:\r\n            //     importSnippet.name = importSnippet.template = importSnippet.template.replace(title + \"'\",prevTabName + \"'\");\r\n                \r\n            //     // code refactoring:\r\n            //     // let importFilename = importSnippet.template.split('from ').pop()\r\n            //     // console.log('importFilename', importFilename);\r\n            //     fileStore['app.' + actualExt] = fileStore['app.' + actualExt].replace(title + \"'\", prevTabName + \"'\");\r\n                \r\n            //     //@ts-ignore\r\n            //     title = prevTabName;\r\n            // }\r\n\r\n\r\n\r\n\r\n            // let newComplete = exports.map((/** @type {string} */ exp) => exp.split(' ').pop()).join(', ');\r\n            // importSnippet.name = importSnippet.template = importSnippet.template.replace(\r\n            //     new RegExp('(\\\\\\{ \\\\\\$\\\\\\{1\\\\\\} \\\\\\})|(\\\\\\{ [\\\\\\w\\\\\\d_, ]* \\\\\\})'), '{ ' + newComplete + ' }'\r\n            // );\r\n\r\n            // console.log('{ ' + newComplete + ' }');\r\n            // console.log(importSnippet.template);\r\n\r\n            // if (defaultExport) {\r\n            //     // editors[2].session.$mode.$highlightRules.$keywordList.unshift(\"import \" + defaultExport.pop() + \" from './\" + newTab.innerText + \"'\");\r\n            //     keyWords.push({\r\n            //         caption: defaultExport[1],\r\n            //         value: defaultExport[1],\r\n            //         meta: 'function',\r\n            //         type: '',\r\n            //         snippet: undefined,  // (defaultExport[1] + '({$1})')\r\n            //     })\r\n            // }\r\n\r\n        }\r\n        ev.target.classList.add('active');\r\n\r\n        editors[2].setValue(fileStore[ev.target.innerText]);\r\n\r\n        globalThis.__debug && console.log('toggle tab...');    \r\n\r\n        // console.log(fileStore[ev.target.innerText].split('\\n').length);\r\n        editors[2].gotoLine(fileStore[ev.target.innerText].split('\\n').length - 1)\r\n        editors[2].focus();        \r\n    }\r\n\r\n\r\n\r\n    // создание нового таба:\r\n\r\n    let newTab = origTab.cloneNode();\r\n    newTab.innerText = title;\r\n\r\n    let prevTab = document.querySelector('.tab.active');\r\n    prevTab && prevTab.classList.toggle('active');\r\n    newTab.classList.add('active');\r\n\r\n    newTab.style.marginRight = '1.25em';\r\n    newTab.onclick = origTab.onclick;\r\n    newTab.ondblclick = origTab.ondblclick;\r\n\r\n    if (playgroundObject.onfileRemove) {\r\n        newTab.oncontextmenu = (/** @type {{ target: { innerText: string | number; parentElement: { removeChild: (arg0: any) => void; }; }; clientX: string; clientY: number; }} */ e) => {\r\n\r\n            let contextMenu = document.querySelector('.context_menu');\r\n            if (contextMenu) contextMenu.classList.remove('hidden')\r\n            else {\r\n                contextMenu = document.body.appendChild(document.createElement('div'));\r\n                contextMenu.className = 'context_menu';\r\n                //@ts-ignore\r\n                contextMenu.tabIndex = 0;\r\n                Object.keys(menuPoints).forEach(key => {\r\n                    let point = contextMenu.appendChild(document.createElement('div'))\r\n                    point.innerText = key;\r\n                    point.addEventListener('click', () => {\r\n\r\n                        contextMenu.classList.toggle('hidden');\r\n                        setTimeout(() => {\r\n                            menuPoints[key] && menuPoints[key](e)                                                        \r\n                        })\r\n                    })\r\n                })\r\n                //@ts-ignore\r\n                contextMenu.onblur = function() {\r\n                    contextMenu.classList.add('hidden');\r\n                }\r\n            }\r\n\r\n            console.log(e);\r\n\r\n\r\n            //@ts-ignore\r\n            contextMenu.style.left = e.clientX + 'px';\r\n            //@ts-ignore\r\n            contextMenu.style.top = e.clientY + 5 + 'px';\r\n            //@ts-ignore\r\n            contextMenu.focus()\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    if (!event.file) {\r\n        \r\n        console.log('fileAttach: editor setValue');\r\n        fileStore[origTab.innerText] = editors[2].getValue();\r\n        fileStore[newTab.innerText] = '';                   // create new\r\n        // editors[2].setValue(fileStore[newTab.innerText]);\r\n\r\n        // добавление нового ключевого слова:\r\n        // editors[2].session.$mode.$highlightRules.$keywordList.push(\"from './\" + newTab.innerText + \"'\");\r\n        // editors[2].session.$mode.$highlightRules.$keywordList.push(\"import {*} from './\" + newTab.innerText + \"'\");\r\n\r\n\r\n        // let moduleName = newTab.innerText.split('.')[0];\r\n        // moduleName = parseInt(moduleName) ? ('_' + moduleName) : moduleName;\r\n        // editors[2].session.$mode.$highlightRules.$keywordList.push(\"import * as \" + moduleName + \" from './\" + newTab.innerText + \"'\");\r\n\r\n        autocompleteExpand(editors[2], importSnippet)\r\n    }\r\n\r\n    target.parentElement.insertBefore(newTab, target);\r\n    editors[2].focus();\r\n\r\n    if (!event.file) {\r\n        editors[2].setValue('');\r\n        //@ts-ignore\r\n        const snippetManager = ace.require('ace/snippets').snippetManager;\r\n        snippetManager.insertSnippet(editors[2], \"export function ${1:funcName} (${2:args}){\\n\\t${3}\\n}\");\r\n    }\r\n    \r\n}\r\n","// @ts-check\r\n\r\nimport { default as extend } from 'emmet';\r\n\r\nimport { debounce } from \"./utils/utils\";\r\nimport { expand } from './features/expantion';\r\nimport { defaultValues } from './features/compiler';\r\nimport { domFuncs, keyWords } from './utils/autocompletion';\r\nimport { playgroundObject, webCompile } from './pageBuilder';\r\nimport { fileAttach } from './features/tabs';\r\nimport { modes } from './features/base';\r\n\r\n\r\n\r\n/**\r\n * setup ace editor: hangs events and configures compilers\r\n * \r\n * @param {{require: (arg: string) => {(): any;new (): any;Range: any;};edit: (arg: any) => any;}} ace - ace library instance\r\n * @param {{ \r\n *      compileFunc: Function;                                                  //// prebinded webCompile\r\n *      syntaxMode: 0 | 1 | 2 | 3                                               //// syntax mode (implied corresponding with vanile/preact/vue/react)\r\n *      controlSave?: (ev: object, compileFunc: Function) => void;              //// callback on ctrlSave\r\n *      storage?: Storage,                                                      //// (custom?) file storage instead of localStorage\r\n *      quickCompileMode: boolean,                                              //// \r\n *      modes?: object[],                                                       //// ? - deprecated field\r\n *      frameworkEnvironment: string[]                                          //// list of lib links to page downloading\r\n * }} editorOptions - options contained prebinded webCompile (compileFunc) and etc\r\n * @obsolete {string[]} modes\r\n * @obsolete {string|number} syntaxMode\r\n * @param {?[string?, string?, string?, object?]} [values] - initial values for editors\r\n */\r\nexport default function initializeEditor(ace, editorOptions, values) {\r\n    \r\n    const syntax = editorOptions.syntaxMode\r\n\r\n    const Range = ace.require('ace/range').Range;\r\n    const delay = 500;\r\n    \r\n    const autoPlay = debounce(\r\n        //@ts-ignore\r\n        () => setTimeout(webCompile.bind(null, !!(editorOptions.syntaxMode % 2), editorOptions.frameworkEnvironment, editorOptions.quickCompileMode), delay), delay\r\n    );\r\n    const fontSize = '.9em';\r\n\r\n    values = values || [];\r\n\r\n\r\n    let cssKeyWords = [\"red\", \"green\", \"blue\", 'gray', 'lightgray', 'lightblue', 'orange', 'white', 'black', 'none'];\r\n    // cssKeyWords = cssKeyWords.concat(['div', 'input', 'select'])\r\n\r\n\r\n    let editors = [].slice.call(document.querySelectorAll('.editor')).map((/** @type {{ id: any; }} */ element, /** @type {number} */ i, /** @type {any[]} */ arr) =>\r\n    {\r\n\r\n        let editor = ace.edit(element.id);        \r\n        editor.setTheme(\"ace/theme/monokai\");\r\n        \r\n        let mode = modes[i];\r\n        // (i && !(i % 2)\r\n        if (i == 2 && syntax % 2) {     //  javascript == 2   &&   syntax == 1 | 3 (preact|react)\r\n            // mode = syntax % 2 ? 'tsx' : mode;  // jsx?\r\n            mode = 'tsx';  // jsx\r\n        }\r\n        editor.session.setMode(\"ace/mode/\" + mode);\r\n        editor.setFontSize(fontSize);\r\n        \r\n        let value = values[i] || (editorOptions.storage || localStorage).getItem(syntax + '__' + modes[i]) || defaultValues[syntax][modes[i]];\r\n        if (value) {\r\n            editor.session.setValue(value)\r\n        }\r\n\r\n        const allCommands = editor.commands.byName;        \r\n\r\n\r\n        // editor.commands.bindKey(\"F9\", null);\r\n        \r\n        // ?\r\n        editor.commands.removeCommand(allCommands.removeline);\r\n        \r\n\r\n        // хотел сделать вырезание, но нет\r\n        // allCommands.removeline.bindKey = { win: \"Ctrl-X\", mac: \"Cmd-X\" }\r\n        // ?\r\n        // editor.commands.addCommand(allCommands.removeline)\r\n\r\n        // удаляет последний символ (добавлена и так)\r\n        // // editor.commands.addCommand(allCommands.cut_or_delete)\r\n\r\n        // добавляем горячую клавишу\r\n        allCommands.copylinesdown.bindKey = { win: \"Ctrl-D\", mac: \"Cmd-D\" };\r\n        // сама команда уже добавлена и так (почему-то надо добавить для 1-го редактора):\r\n        editor.commands.addCommand(allCommands.copylinesdown);\r\n        \r\n        \r\n        (i < 2) && editor.textInput.getElement().addEventListener('input', autoPlay);\r\n\r\n        editor.textInput.getElement().addEventListener('keydown', function (/** @type {{ ctrlKey: any; keyCode: number; key: string; preventDefault: () => void; }} */ event)\r\n        {\r\n\r\n            // console.log(event);\r\n\r\n            (event.ctrlKey && event.keyCode === 190) && (arr[i + 1] || arr[0]).querySelector('textarea').focus();\r\n            (event.ctrlKey && event.key === 'ArrowUp') && expand({ currentTarget: document.querySelector('.expand')})            \r\n            if ( event.key === 'F9')      // ctrl+s\r\n            {\r\n                event.preventDefault();\r\n                // binding is lost !!! \r\n                webCompile(!!(editorOptions.syntaxMode % 2), editorOptions.frameworkEnvironment, editorOptions.quickCompileMode || false);\r\n            }\r\n            else if (event.ctrlKey && event.keyCode === 83) {\r\n                \r\n                // ctrl + s\r\n                console.log(editorOptions);\r\n                // event.preventDefault(), (editorOptions.controlSave || webCompile)();\r\n\r\n                event.preventDefault(), (editorOptions.controlSave\r\n                    ? editorOptions.controlSave(\r\n                        event, webCompile.bind(null, !!(editorOptions.syntaxMode % 2), editorOptions.frameworkEnvironment, editorOptions.quickCompileMode || false)\r\n                    )\r\n                    : webCompile(!!(editorOptions.syntaxMode % 2), editorOptions.frameworkEnvironment, editorOptions.quickCompileMode || false));\r\n            }\r\n            else if (event.ctrlKey && event.key === 'f'){\r\n\r\n                // это не работает (!):\r\n\r\n                // event.preventDefault()\r\n                // return false\r\n            }\r\n        })\r\n\r\n        if (i === 0 && window.outerWidth > 600) {\r\n\r\n            \r\n            editor.setOptions(\r\n                {\r\n                    enableBasicAutocompletion: true,\r\n                    enableSnippets: true,\r\n                    enableLiveAutocompletion: true,\r\n                    fontSize,\r\n                    // placeholder: \"Enter your \" + modes[i] + \" Code\",\r\n                    // enableEmmet: true,   //                       don't work   \r\n                }\r\n            );\r\n\r\n            editor.completers = editor.completers.slice();\r\n\r\n\r\n            const cursorText = editor.container.querySelector('textarea')\r\n            cursorText.addEventListener('keydown', function tabHandler(/** @type {{ key: string; }} */ e) {                \r\n                if (e.key === 'Tab'){\r\n                    if (editor.completer) {\r\n                        editor.completer.keyboardHandler.removeCommand(editor.completer.keyboardHandler.commands.Tab);\r\n                        cursorText.removeEventListener('keydown', tabHandler)\r\n                        console.log('removing tab hot key from autocomplete popup');\r\n                    }\r\n                }\r\n            })\r\n\r\n            editor.commands.addCommand(  // [ indent,\r\n                \r\n                {\r\n                    name: \"extend\",\r\n                    exec: function () {\r\n                        let cursor = editor.getCursorPosition();\r\n                        let row = cursor.row;\r\n\r\n                        // editor.completer && editor.completer.keyboardHandler.removeCommand(editor.completer.keyboardHandler.commands.Tab)\r\n\r\n                        if (cursor.column == editor.session.getLine(row).length) {\r\n                            \r\n                            let line = editor.session.getLine(row);\r\n                            \r\n                            let startChar = Math.max(line.lastIndexOf(' ') + 1, 0);\r\n                            let endChar = cursor.column;\r\n                            let range = new Range(row, startChar, row, endChar);\r\n\r\n                            let textRange = line.slice(startChar, endChar);\r\n                            let code = extend(textRange)\r\n                            // let text = editor.session.getValue();\r\n                            editor.session.replace(range, code)\r\n\r\n                            editor.moveCursorTo(row, !(textRange.startsWith('.') || textRange.startsWith('#'))\r\n                                ? startChar + code.length - textRange.length - 3\r\n                                : startChar + code.length - 6\r\n                            )\r\n\r\n                            return;\r\n                        }\r\n                        editor.indent();\r\n                    },\r\n                    bindKey: { win: 'Tab' }\r\n                }, //  expandSnippet ]\r\n                    \r\n                \r\n            );\r\n\r\n        }\r\n        else {  //  if (i)\r\n\r\n            editor.setOptions(\r\n                {\r\n                    enableBasicAutocompletion: true,\r\n                    enableSnippets: true,\r\n                    enableLiveAutocompletion: true,\r\n                    fontSize,\r\n                    // maxSize: Infinity\r\n                    \r\n                    // placeholder: \"Enter your \" + modes[i] + \" Code\",\r\n                    // enableEmmet: true        \r\n                }\r\n            );\r\n\r\n            // html (on width < 600)\r\n            if (!i) {\r\n                editor.completers = editor.completers.slice();\r\n                editor.completers.push({\r\n                    getCompletions: function htmlCompleter (editor, session, pos, prefix, callback) {                        \r\n                        callback(null,\r\n                            ['fill'].concat(cssKeyWords)\r\n                                .map(w => {\r\n                                    // editors[i].session.$mode.$highlightRules.$keywordList.push(w);\r\n                                    return {\r\n                                        caption: w,\r\n                                        value: w,\r\n                                        // snippet: '<' + w + '>',\r\n                                        meta: \"attribute\"\r\n                                    }\r\n                                })\r\n                                .concat(['svg', 'select', 'option'].map(w => {\r\n                                    return {\r\n                                        caption: '<' + w + '>',\r\n                                        value: w,\r\n                                        snippet: '<' + w + '>${1}</' + w + '>',\r\n                                        meta: \"tag\"\r\n                                    }\r\n                                })).concat(['input'].map(w => {\r\n                                    return {\r\n                                        caption: '<' + w + '>',\r\n                                        value: w,\r\n                                        snippet: '<' + w + '/>',\r\n                                        meta: \"tag\"\r\n                                    }\r\n                                }))\r\n                        )\r\n                    }\r\n                })                \r\n            }\r\n            // style\r\n            else if (i === +!!i) {\r\n\r\n                editor.commands.on(\"afterExec\", function (e) {\r\n                    window['__debug'] && console.log(e.command.name);\r\n                    if (e.command.name.toLowerCase() === 'return') {\r\n                        webCompile(!!(editorOptions.syntaxMode % 2), editorOptions.frameworkEnvironment, editorOptions.quickCompileMode)\r\n                    }\r\n                    // if (e.command.name == \"insertstring\" && /^[\\w.]$/.test(e.args)) {\r\n                    //     editor.execCommand(\"startAutocomplete\")\r\n                    // }\r\n                })\r\n\r\n                const colorsCompleter = {                    \r\n                    getCompletions: function cssCompleter (editor, session, pos, prefix, callback) {\r\n                        // console.log(pos);                        \r\n                        callback(null, cssKeyWords.concat(['div', 'input', 'select']).map(\r\n                            function (word) {\r\n                                return {\r\n                                    caption: word,\r\n                                    value: word,\r\n                                    meta: \"static\"\r\n                                };\r\n                            }\r\n                        ));\r\n                    },\r\n                    // getDocTooltip: function (item) {\r\n                    //     if (item.type == \"snippet\" && !item.docHTML) {\r\n                    //         item.docHTML = [\r\n                    //             \"<b>\", lang.escapeHTML(item.caption), \"</b>\", \"<hr></hr>\",\r\n                    //             lang.escapeHTML(item.snippet)\r\n                    //         ].join(\"\");\r\n                    //     }\r\n                    // }\r\n                };\r\n\r\n                editor.completers = editor.completers.slice();\r\n                editor.completers.push(colorsCompleter)\r\n            }\r\n            // javascript:\r\n            else if(i === 2) {\r\n            \r\n\r\n                // AUTO COMPLETION:\r\n\r\n                const domCompleter = {\r\n                    getCompletions: function jsCompleter (editor, session, pos, prefix, callback) {                        \r\n                        // prefix !== '.' ? [] :\r\n                        console.log(pos);\r\n                        // editors[2].session.getLine(2).slice(0, 9).match(/([\\w\\d]+)\\.\\w+$/m)[1]\r\n                        // get object for autocompletion\r\n\r\n                        // let token = editor.session.getTokenAt(pos.row, pos.column)\r\n                        // if (token.type == 'string') {\r\n                        //     console.log('string token');\r\n                        // }\r\n                        \r\n                        callback(null, keyWords);\r\n                    },\r\n                    getDocTooltip: function (/** @type {{ docHTML: string; caption: string; }} */ item) {\r\n                        // item['type'] === 'snippet'\r\n                        if (!item.docHTML || (item['meta'] === 'function' && domFuncs[item.caption] && domFuncs[item.caption].sign)) {\r\n                            let hint = domFuncs[item.caption];\r\n                            if (hint) {\r\n                                let args = Object.keys(hint.sign || {}).map(item => item + ': ' + hint.sign[item].type).join(', ');\r\n                                // item.docHTML = '<h5>' + (hint.value || item.caption) + '(' + args + ') : ' + hint['return'] + '</h5><hr>'\r\n                                item.docHTML = '<h5>' + (hint.origin || item.caption) + '(' + args + ') : ' + hint['return'] + '</h5><hr>'\r\n                                item.docHTML += '<p>' + (hint.desc || hint.value) + '</p>'\r\n                                let argsDesc = ''\r\n                                for (const key in hint.sign) {\r\n                                    argsDesc += '<li><b>' + key + ':' + (hint.sign[key].type || 'any') + '</b> - ' + hint.sign[key].desc\r\n                                }\r\n                                item.docHTML += '<ul>' + argsDesc + '</ul>'\r\n                                // item.docHTML += '<h6>return ' + hint['return'] + '</h6>'\r\n                            }\r\n                            console.log(item);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // editor.completers = editor.completers.slice();\r\n                editor.completers.push(domCompleter);\r\n\r\n\r\n\r\n                // REMOVE TAB AUTO COMPLETION IN STRING:                \r\n\r\n                const cursorText = editor.container.querySelector('textarea')\r\n                cursorText.addEventListener('keydown', function tabHandler(/** @type {{ key: string; }} */ e) {\r\n                    if (e.key === 'Tab') {\r\n                        if (editor.completer) {\r\n\r\n                            editor.completer.keyboardHandler.removeCommand(editor.completer.keyboardHandler.commands.Tab);\r\n                            cursorText.removeEventListener('keydown', tabHandler)\r\n                            console.log('removing tab hot key from autocompletion');\r\n\r\n                            // var position = editor.getCursorPosition();\r\n                            // var token = editor.session.getTokenAt(position.row, position.column);\r\n                            // if (token.type === 'string') {\r\n                            //     editor.completer.keyboardHandler.removeCommand(editor.completer.keyboardHandler.commands.Tab);\r\n                            //     cursorText.removeEventListener('keydown', tabHandler)                                \r\n                            //     console.log('removing tab hot key from autocompletion');\r\n                            // }\r\n                        }\r\n                    }\r\n                })\r\n\r\n\r\n\r\n                //AUTO RENAME:\r\n\r\n                editor.commands.addCommand(\r\n                    {\r\n                        name: \"rename\",\r\n                        exec: function () {\r\n                            var position = editor.getCursorPosition();\r\n                            var token = editor.session.getTokenAt(position.row, position.column);\r\n                            if (token.type == \"identifier\") {\r\n                                let newValue = prompt('', token.value)\r\n                                if (newValue !== token.value) {\r\n                                    if (newValue && newValue.match(/^[\\w_][\\w_\\d]*$/m)) {\r\n                                        let range = null;\r\n                                        let options = {\r\n                                            // backwards: true,\r\n                                            wrap: true,\r\n                                            // caseSensitive: true,\r\n                                            // range: null,\r\n                                            wholeWord: true,\r\n                                            // regExp: false\r\n                                        }\r\n                                        let threshold = editor.findAll(token.value);\r\n                                        if (threshold) {\r\n                                            const pattern = 'import \\\\\\{[\\w\\d_\\\\\\. ,]*' + token.value + '[\\w\\d_\\\\\\. ,]*\\\\\\} from [\\'\"]\\\\\\./([\\\\\\w\\\\\\d_\\\\\\.]+)';\r\n                                            editor.find(new RegExp(pattern), { regExp: true })\r\n                                            const match = editor.getSelectedText().match(pattern)\r\n                                            if (match) {\r\n                                                let storeName = match[1];\r\n                                                let module = playgroundObject.fileStorage[storeName];\r\n                                                if (!module) alert('Связанный модуль ' + storeName + ' не найден')\r\n                                                else {\r\n                                                    let replacePattern = '(^' + token.value + ')|( ' + token.value + ')|(' + token.value + ' )';\r\n                                                    console.log(replacePattern);\r\n                                                    playgroundObject.fileStorage[storeName] = module.replace(new RegExp(replacePattern, 'm'), function(substring, args) {\r\n                                                        console.log(arguments);\r\n                                                        return substring.replace(token.value, newValue);\r\n                                                    })\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        while ((range = editor.find(token.value, options)) && threshold--) {\r\n                                            console.log('replace...');\r\n                                            editor.session.replace(range, newValue);                                            \r\n                                        }\r\n                                    }\r\n                                    else if(newValue !== null) {\r\n                                        alert('Введите корректное имя для идентификатора');\r\n                                    }\r\n                                }\r\n                            }\r\n                        },\r\n                        bindKey: { win: 'F2' }\r\n                        // insted of expand/collapse\r\n                    }\r\n                )\r\n\r\n\r\n                // GO TO DEFINITION:\r\n                \r\n                editor.container.addEventListener('click', function (/** @type {{ ctrlKey: boolean; }} */ e) {\r\n                    \r\n                    var position = editor.getCursorPosition();\r\n                    var token = editor.session.getTokenAt(position.row, position.column);\r\n                    if (e.ctrlKey && token.type == \"identifier\") {\r\n                        \r\n                        console.log(token);\r\n                        let code = editor.session.getValue();\r\n\r\n                        const pattern = new RegExp('(var|let|const|function|class|import \\{ ?) ?' + token.value)\r\n                        const match = editor.session.getValue().match(pattern);\r\n\r\n                        if (match) {\r\n                            \r\n                            let linesCount = code.slice(0, match.index).split('\\n').length - 1;\r\n                            if (linesCount === position.row) {\r\n                                // нашел себя же (ту же строку)\r\n                                // => ищем дальше (//TODO//)\r\n                            }\r\n                            else {\r\n                                let line = editor.session.getLine(2);\r\n                                if (line.startsWith('import')) {\r\n                                    let r = line.match(new RegExp(\"from ['\\\"]\\\\\\./([\\\\\\w\\\\\\d_\\\\\\.]+)'\"))\r\n                                    if (r) {\r\n                                        let filename = r[1];\r\n                                        // find inside filename: \r\n                                        let module = playgroundObject.fileStorage[filename];\r\n                                        if (!module) {\r\n                                            editor.removeSelectionMarkers(editor.session.$selectionMarkers);\r\n                                            alert('Отсутвует модуль ' + filename)\r\n                                            return;\r\n                                        }\r\n                                        let submatch = module.match(pattern);\r\n                                        if (submatch) {\r\n                                            // переключаемся на эту вкладку\r\n                                            // let tabIndex = Object.keys(playgroundObject.fileStorage).indexOf(filename)\r\n                                            const tabs = document.querySelector('.tabs').children;\r\n                                            let activeTab = [].slice.call(tabs).filter(f => f.innerText == filename).pop()\r\n                                            //@ts-ignore\r\n                                            activeTab.click()\r\n\r\n                                            console.log(submatch);\r\n                                            // переходим к определению\r\n                                            linesCount = module.slice(0, match.index).split('\\n').length - 1;\r\n                                            editor.moveCursorTo(linesCount, 8 + submatch[1].length);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    editor.moveCursorTo(linesCount, 0)\r\n                                }\r\n                            }\r\n                        }\r\n                        editor.removeSelectionMarkers(editor.session.$selectionMarkers)\r\n                    }\r\n                });\r\n\r\n            }\r\n        }                \r\n        \r\n        return editor;\r\n\r\n    });\r\n\r\n    \r\n    // read modules:\r\n\r\n    //@ts-ignore\r\n    let fileStorage = editors.fileStorage = window.fileStorage = window['fileStore'] || { _active: 0};\r\n    // fileStorage    \r\n    let modulesStorage = values[3] || (editorOptions.storage || localStorage).getItem('_modules');\r\n    \r\n    /// включаем вкладки:\r\n    if (~Object.keys(playgroundObject.modes[2]).slice(1).map(w => '/* ' + w + ' */').indexOf(editors[2].session.getLine(0))) {\r\n        let tabs = document.querySelector('.tabs');\r\n        tabs && tabs.classList.add('enabled')\r\n    }        \r\n\r\n    console.log('modules Storage get:');\r\n\r\n    if (modulesStorage) {\r\n\r\n        // create tabs:\r\n\r\n        let _modules = typeof modulesStorage === 'object' ? modulesStorage : JSON.parse(modulesStorage);\r\n        let fileCreateTab = document.querySelector('.tabs .tab:last-child');\r\n\r\n        let i = 0;\r\n\r\n        if (fileCreateTab) {\r\n            for (const key in _modules) {\r\n                if (Object.hasOwnProperty.call(_modules, key)) {\r\n                    fileStorage[key] = _modules[key];\r\n                    \r\n                    if (/app\\.(j|t)sx?/.test(key) || key == void 0 + '') continue;\r\n                    console.log('create tab: ' + key);\r\n                    \r\n                    if (i++ || true) {\r\n                        //@ts-ignore\r\n                        // setTimeout(() => fileCreate.click({ target: fileCreate, file: key }));\r\n                        fileAttach({ target: fileCreateTab, file: key, editors })\r\n                    }\r\n                    else {                        \r\n                        editors[2].setValue(_modules[key]);                                     // set editor value\r\n                        // clear selection\r\n                        editors[2].session.selection.setRange(new Range(0, 0, 0, 0))\r\n                    }\r\n                }\r\n            }\r\n\r\n            let activeTab = document.querySelector('.tabs .tab.active');\r\n            activeTab && activeTab.classList.toggle('active');\r\n\r\n            document.querySelector('.tabs .tab').classList.add('active');\r\n        }\r\n\r\n        playgroundObject.fileStorage = fileStorage;\r\n    }      \r\n\r\n\r\n    // initResizers()\r\n\r\n    return editors;\r\n\r\n}\r\n\r\n","//@ts-check\r\n\r\nimport { playgroundObject } from \"../pageBuilder\";\r\n\r\n\r\nlet hrSplitter = document.querySelector('.h_line');\r\nlet vertSplitter = document.querySelector('.v_line');\r\nlet centerSplitter = document.querySelector('.center_line');\r\n\r\nconst htmlEditor = document.getElementById('htmleditor')\r\nconst styleEditor = document.getElementById('csseditor')\r\nconst jsEditor = document.getElementById('jseditor')\r\nconst editionView = document.querySelector('.view')\r\n\r\nlet hoSeized = false;\r\nlet vertSeized = false;\r\nlet allSeized = false;\r\n\r\nconst container = document.querySelector('.md_container');\r\nconst header = document.querySelector('.header');\r\n\r\n// const headerHeight = header.offsetHeight;\r\n// const headerHeight = container.offsetTop;\r\nconst headerHeight = container.getBoundingClientRect().top;\r\nconst paddingTop = parseFloat(getComputedStyle(container).padding) * 2 || 0;\r\n//@ts-ignore\r\nwindow.__debug && console.log(paddingTop);\r\n\r\n\r\nlet tabs = null;\r\n\r\n/**\r\n * Initialize resize lines\r\n */\r\nexport function initResizers() {    \r\n\r\n    container.addEventListener('mousedown', function (event) {\r\n        if (event.target === hrSplitter) {\r\n\r\n            hoSeized = true;\r\n            tabs = document.querySelector('.tabs');\r\n            // let iframe = editionView.querySelector('iframe');\r\n            // iframe.contentDocument.onmouseup = function (event) { seized = false; };\r\n        }\r\n        else if (event.target === vertSplitter) vertSeized = true\r\n        else {\r\n            allSeized = event.target === centerSplitter;\r\n        }\r\n    })\r\n\r\n    window.addEventListener('resize', function resetSize(event) {\r\n        [hrSplitter, vertSplitter, centerSplitter, htmlEditor, styleEditor, jsEditor, editionView].forEach(el => {\r\n            //@ts-ignore\r\n            el.style = null;\r\n        })\r\n    })\r\n    container.addEventListener('mouseup', function (event) {\r\n        if (hoSeized || allSeized) {\r\n            \r\n            playgroundObject.editors.forEach(function(/** @type {{ resize: () => void; }} */ elem) {\r\n                elem.resize();\r\n                console.log('resize...');\r\n            })\r\n        }\r\n        hoSeized = vertSeized = allSeized = false;\r\n        globalThis.__debug && console.log('mouseup on resize...');\r\n    })\r\n    \r\n    container.addEventListener('mousemove', function(event) {\r\n\r\n        //@ts-ignore\r\n        if (hoSeized) hTune(event)\r\n        //@ts-ignore\r\n        else if (vertSeized) vTune(event)\r\n        else if (allSeized) {\r\n            //@ts-ignore\r\n            hTune(event) || vTune(event)\r\n        }\r\n    })\r\n}\r\n\r\n\r\n\r\n/**\r\n * @param {MouseEvent} event\r\n */\r\nfunction hTune(event) {\r\n    \r\n    let marginTop = headerHeight;    \r\n\r\n    //@ts-ignore\r\n    hrSplitter.style.top = event.clientY - paddingTop + 'px';\r\n    //@ts-ignore\r\n    vertSplitter.style.height = event.clientY - paddingTop + 'px';\r\n    //@ts-ignore\r\n    centerSplitter.style.top = event.clientY - paddingTop + 'px';\r\n\r\n\r\n    htmlEditor.style.height = event.clientY - marginTop + 'px';\r\n    styleEditor.style.height = event.clientY - marginTop + 'px';\r\n\r\n    // let lowerHeight = container.offsetHeight - event.clientY - paddingTop - 10 + marginTop + 'px';\r\n    //@ts-ignore\r\n    let lowerHeight = container.offsetHeight - event.clientY - (paddingTop || 10) + marginTop + 'px';        \r\n\r\n    //@ts-ignore\r\n    jsEditor.style.height = editionView.style.height = lowerHeight;\r\n    \r\n    // выравниваем вкладки: \r\n    if (tabs) {\r\n        // console.log(tabs.offsetHeight);\r\n        // console.log(headerHeight);\r\n        \r\n        //@ts-ignore\r\n        tabs.style.top = event.clientY - tabs.offsetHeight + 0 - headerHeight + 'px';\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * @param {MouseEvent} event\r\n */\r\nfunction vTune(event) {\r\n    let pref = 14;\r\n    let prefLine = 10;\r\n    // let prefLine = 20;\r\n    // let pref = 32;\r\n    let post = 0;\r\n\r\n    //@ts-ignore\r\n    vertSplitter.style.left = event.clientX - prefLine + 'px';\r\n    //@ts-ignore\r\n    hrSplitter.style.width = event.clientX - prefLine + 'px';\r\n    //@ts-ignore\r\n    centerSplitter.style.left = event.clientX - prefLine + 'px';\r\n\r\n    htmlEditor.style.width = event.clientX - pref + 'px';\r\n    jsEditor.style.width = event.clientX - pref + 'px'\r\n    //@ts-ignore\r\n    styleEditor.style.width = container.offsetWidth - event.clientX + post + 'px'\r\n    //@ts-ignore\r\n    editionView.style.width = container.offsetWidth - event.clientX + post + 'px'\r\n}","//@ts-check\r\n\r\n// @ts-ignore\r\nwindow.evalCode = function evalCode(event) {\r\n    if (event.key == 'Enter') {\r\n        let iframe = document.querySelector('iframe');\r\n\r\n        iframe.contentWindow.postMessage(event.target.value, '*')\r\n\r\n        // let error = ''\r\n        // try {            \r\n        //     var result = iframe.contentWindow.eval(event.target.value);\r\n        // }\r\n        // catch (e) {\r\n        //     result = error = '> ' + e.stack.split(':').shift() + ': ' + e.message;\r\n        // }\r\n\r\n        const lines = document.querySelector('.console .lines');\r\n        let line = lines.appendChild(document.createElement('div'));\r\n        //@ts-ignore\r\n        line.style = 'border-bottom: none;padding-bottom: 0;'\r\n\r\n        let snipElem = line.appendChild(document.createElement('div'));\r\n        snipElem.textContent = '> ' + event.target.value;\r\n        snipElem.className = 'input';\r\n        snipElem.style.marginBottom = '0'\r\n\r\n        // let resultElem = line.appendChild(document.createElement('div'));\r\n        // resultElem.textContent = typeof result === 'object'\r\n        //     ? (~result.toString().indexOf('HTML')\r\n        //         ? result\r\n        //         : JSON.stringify(result))\r\n        //     : result;\r\n        // if (error) {\r\n        //     resultElem.style.color = 'red';\r\n        //     // resultElem.style.fontFamily = \"'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif\";\r\n        //     resultElem.style.fontFamily = \"monospace\";\r\n        // }\r\n\r\n        shellStore = JSON.parse(sessionStorage.getItem('shellStore') || '[]')\r\n        shellStore.push(event.target.value)        \r\n        if (shellStore.length > shellStoreLength) {\r\n            shellStore.shift()\r\n        }\r\n        currentShellStoreIndex = shellStore.length - 1;\r\n        sessionStorage.setItem('shellStore', JSON.stringify(shellStore));\r\n\r\n\r\n        event.target.value = ''\r\n\r\n        // lines.scrollTo(0, lines.scrollHeight);\r\n\r\n        event.target.focus()\r\n    }\r\n    else if (currentShellStoreIndex !== undefined && ~['ArrowUp', 'ArrowDown'].indexOf(event.key)) {\r\n        if (shellStore.length) {\r\n            console.log(currentShellStoreIndex);            \r\n            \r\n            event.target.value = shellStore[currentShellStoreIndex] || '';\r\n\r\n            if (event.key.slice(-2) == 'Up') {\r\n                currentShellStoreIndex = Math.max(currentShellStoreIndex - 1, 0)\r\n            }\r\n            else if (event.key.slice(-4) == 'Down') {\r\n                currentShellStoreIndex = Math.min(currentShellStoreIndex + 1, shellStore.length - 1)\r\n            }\r\n            \r\n            setTimeout(() => {\r\n                event.target.selectionStart = event.target.selectionEnd = event.target.value.length\r\n            })\r\n            \r\n            \r\n\r\n        }\r\n    }\r\n}\r\n\r\nlet shellStore = []\r\nconst shellStoreLength = 10;\r\nlet currentShellStoreIndex = undefined;\r\n","// @ts-check\r\n\r\nimport initializeEditor from \"./aceInitialize\";\r\nimport { createPage, webCompile, playgroundObject } from \"./pageBuilder\";\r\n\r\nimport { expand } from \"./features/expantion\";\r\nimport { initResizers } from \"./features/resizing\";\r\nimport { babelCompiler, compilers } from \"./features/compiler\";\r\nimport { commonStorage } from \"./utils/utils\";\r\nimport { fileAttach } from \"./features/tabs\";\r\n\r\nimport { ChoiceMenu } from \"./ui/ChoiceMenu\";\r\nimport { modes } from \"./features/base.js\";\r\n\r\nimport \"./features/consoleDebug\";\r\n\r\n\r\n\r\n/**\r\n * @type { Array<keyof compilers>}\r\n */\r\nconst frameworkEnvironment = []\r\n\r\n/**\r\n * @param { string[] } fwrkEnv\r\n * @param {keyof compilers} envName\r\n */\r\nfunction updateEnvironment(fwrkEnv, envName) {\r\n    const libs = compilers[envName] || [];\r\n    fwrkEnv.splice(0, fwrkEnv.length);\r\n    libs.forEach((/** @type {string} */ lib) => fwrkEnv.push(lib));\r\n    \r\n    window['__DEBUG'] && console.log(fwrkEnv);\r\n}\r\n\r\n\r\nwindow.addEventListener('message', function (event) {\r\n    \r\n    console.log(event.data);\r\n    \r\n    // let value = event.data.value;\r\n    let consoleJar = document.querySelector('.console .lines');\r\n    if (consoleJar) {\r\n        let line = consoleJar.appendChild(document.createElement('div'));        \r\n        // line.innerText = event.data.value;\r\n        let snipElem = line.appendChild(document.createElement('div'));\r\n        snipElem.textContent = '> ' + typeof event.data.value === 'object'\r\n            ? (~event.data.value.toString().indexOf('HTML')\r\n                ? event.data.value\r\n                : JSON.stringify(event.data.value))\r\n            : event.data.value;\r\n\r\n        if (event.data.error) {\r\n            snipElem.style.color = 'red';\r\n            // resultElem.style.fontFamily = \"'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif\";\r\n            snipElem.style.fontFamily = \"monospace\";\r\n        }\r\n\r\n        consoleJar.scrollTo(0, consoleJar.scrollHeight);\r\n\r\n        // event.target.focus()\r\n    }\r\n\r\n    // let line = window.parent.document.querySelector('.console .lines').appendChild(document.createElement('div'));\r\n    // line.innerText = typeof value === 'object' ? JSON.stringify(value) : value;\r\n})\r\n\r\n\r\n/**\r\n * @param {[string, string, string, Storage|object?]} values\r\n * @param {{\r\n *      onControlSave?: Function, \r\n *      tabAttachSelector?: string,\r\n *      modes?: [object?, object?, object?], \r\n *      onfilerename?: Function,     \r\n *      onfileRemove?: (s: string) => void,\r\n *      additionalFiles?: Storage|object,\r\n *      quickCompileMode?: boolean\r\n * }?} options\r\n * @returns {unknown[]}\r\n */\r\nexport function initialize(values, options) {\r\n\r\n    options = options || {};\r\n    \r\n    /**\r\n     * @type {number} - 0 | 1 | 2 | 3 - its mean vanile|preact|vue|react\r\n     */\r\n    let syntaxMode = Number.parseInt((commonStorage || localStorage).getItem('mode') || '0');\r\n    //@ts-ignore\r\n    document.getElementById('compiler_mode').selectedIndex = syntaxMode;\r\n\r\n    // js mode:\r\n    const jsxMode = !!(syntaxMode % 2);\r\n    if (jsxMode) {\r\n        document.getElementById('jseditor').classList.add('dis_errors');\r\n    }\r\n\r\n    playgroundObject.modes = options.modes;\r\n    playgroundObject.onfilerename = options.onfilerename\r\n    playgroundObject.onfileRemove = options.onfileRemove\r\n\r\n    debugger;\r\n    //@ts-ignore\r\n    updateEnvironment(frameworkEnvironment, Object.keys(compilers)[syntaxMode])\r\n\r\n    // Object.values(compilers)[syntaxMode].forEach(link => frameworkEnvironment.push(link));\r\n    const updateEnv = updateEnvironment.bind(null, frameworkEnvironment);\r\n    \r\n    // @ts-ignore\r\n    let compileFunc = syntaxMode ? webCompile.bind(null, jsxMode) : webCompile;\r\n\r\n    initResizers()\r\n\r\n    // let compileFunc = mode ? webCompile.bind(null, mode > 1, mode) : webCompile;\r\n    // console.log(mode);\r\n    // console.log(Object.values(compilers)[mode]);\r\n\r\n    const editorOptions = {\r\n        compileFunc,\r\n        frameworkEnvironment,\r\n        quickCompileMode: options.quickCompileMode,\r\n        controlSave: options.onControlSave,\r\n        storage: commonStorage,\r\n        syntaxMode,\r\n    }\r\n\r\n    if (options.additionalFiles) {\r\n        //@ts-ignore\r\n        values = values || [];\r\n        values[3] = options.additionalFiles\r\n    }\r\n\r\n    // @ts-ignore\r\n    let editors = playgroundObject.editors = initializeEditor(ace, editorOptions, values)\r\n\r\n    \r\n\r\n    /**\r\n     * Choice arg settings:\r\n     */\r\n\r\n\r\n    \r\n    if (options.modes) {\r\n        !customElements.get('choice-menu') && customElements.define('choice-menu', ChoiceMenu);\r\n        console.log(options.modes);\r\n        options.modes.forEach(function (/** @type { {[k: string]: {tabs?: true, src?: string, target? : object, ext?: string }} } */ mode, i) {\r\n\r\n            let items = [];  // ['css','less','stylus']\r\n\r\n            if (mode && (items = Object.keys(mode)).length > 1) {\r\n\r\n                const settingsElement = editors[i].container.appendChild(document.createElement('choice-menu'));\r\n                settingsElement.className = 'settings';\r\n                settingsElement.addEventListener('selected_changed', (/** @type { CustomEvent } */ e) => {\r\n                    console.log(e.detail);\r\n                    console.log(mode);\r\n\r\n                    /**\r\n                     * @type {{src?: string, tabs?: true, mode?: 'html'|'css'|'javascript', ext?: string}}\r\n                     */\r\n                    const modeOptions = mode[e.detail.value];\r\n                    // const link = options.modes[i][e.detail.value];\r\n                    // console.log(link)\r\n\r\n                            \r\n                    // MULTITABS MODE:\r\n                \r\n                    if (i && i - 1)\r\n                    {\r\n                        const multitabs = modeOptions && modeOptions.tabs;\r\n                        var tabs = document.querySelector('.tabs');  //  + (multitabs ? '' : '.enabled')                        \r\n                        if (tabs) {\r\n                            //@ts-ignore\r\n                            tabs.style.transition = null;\r\n                            if (multitabs) {\r\n                                if (!tabs.classList.contains('enabled')) {\r\n                                    // enable tab:\r\n                                    tabs.classList.add('enabled')\r\n                                }\r\n                                else {\r\n                                    // switch to first tab:\r\n                                    //@ts-ignore\r\n                                    tabs.children[0] && tabs.children[0].click()\r\n                                }\r\n                            }\r\n                            else if (!multitabs && tabs.classList.contains('enabled')) {\r\n                                tabs.classList.remove('enabled')\r\n                            }                                \r\n                        }\r\n                    }\r\n                    \r\n                    // upload to frame will in pageBuilder, here just is highlight change\r\n                    (i === 1) && editors[i].session.setMode(\"ace/mode/\" + ((modeOptions && modeOptions.mode) || e.detail.value));\r\n\r\n\r\n\r\n\r\n                    \r\n                    // REPLACE TITLE MARK OF THE MODE (FLAG) IN BEGIN OF FILE:\r\n\r\n                    //@ts-ignore\r\n                    var Range = ace.require(\"ace/range\").Range;\r\n\r\n                    let markLine = editors[i].session.getLine(0);\r\n                    const markValue = \"/* \" + e.detail.value + \" */\";\r\n\r\n                    if (markLine.startsWith('/*')) {\r\n                        editors[i].session.replace(new Range(0, 0, 0, markLine.length), markValue)\r\n                    }\r\n                    else {\r\n                        editors[i].session.insert({ row: 0, column: 0 }, markValue + '\\n\\n')\r\n                    }\r\n                    \r\n\r\n                    // RENAME FILES:\r\n\r\n                    console.log('rename');\r\n\r\n                    if (tabs) {\r\n\r\n                        if (Object.keys(playgroundObject.fileStorage).length > 1) {\r\n                            \r\n                            if (!playgroundObject.fileStorage['app' + modeOptions.ext]) {\r\n\r\n                                // rename tabs:\r\n\r\n                                const jsPattern = /([\\w_\\d]+)\\.js(x)$/m;\r\n                                const tsPattern = /([\\w_\\d]+)\\.ts(x)$/m;\r\n                                \r\n                                [].slice.call(tabs.querySelectorAll('.tab')).forEach((/** @type {HTMLElement} */ element) => {\r\n                                    if (modeOptions.ext) {\r\n                                        if (!element.innerText.endsWith(modeOptions.ext)) {\r\n                                            element.innerText = element.innerText.replace(jsPattern, '$1.ts');\r\n                                        }\r\n                                    }\r\n                                    else if (!element.innerText.endsWith('.js')) {\r\n                                        element.innerText = element.innerText.replace(tsPattern, '$1.js');\r\n                                    }\r\n                                });\r\n\r\n                                // file name rename:\r\n\r\n                                /**\r\n                                 * @type {[RegExp, string]}\r\n                                 */\r\n                                const extensions = modeOptions.ext ? [jsPattern, '$1.ts'] : [tsPattern, '$1.js']\r\n\r\n                                let storageFiles = Object.keys(playgroundObject.fileStorage).map(\r\n                                    k => ({ [k.replace(extensions[0], extensions[1])]: playgroundObject.fileStorage[k] })\r\n                                );\r\n                                playgroundObject.fileStorage = Object.assign({}, ...storageFiles)\r\n\r\n\r\n                                // imports refactoring:\r\n\r\n                                for (let file in playgroundObject.fileStorage) {\r\n                                    if (typeof playgroundObject.fileStorage[file] === 'string') {\r\n                                        playgroundObject.fileStorage[file] = playgroundObject.fileStorage[file].replace(extensions[0], extensions[1]);\r\n                                    }\r\n                                }\r\n\r\n                                let pos = editors[2].find(extensions[0] + \"'\")\r\n                                pos && editors[2].getSession().replace(pos, extensions[1] + \"'\")\r\n                            }\r\n\r\n                        }\r\n                        \r\n                        if (modeOptions.ext) {\r\n                            const firstTab = tabs.children[0];\r\n                            //@ts-ignore\r\n                            if (!~firstTab.innerText.indexOf(modeOptions.ext, firstTab.innerText.length - modeOptions.ext.length)) {\r\n                                //@ts-ignore\r\n                                firstTab.innerText = firstTab.innerText.split('.').shift() + modeOptions.ext\r\n                            }\r\n                        }\r\n\r\n                    }                    \r\n                })\r\n\r\n                // const value = editors[i].getValue()\r\n                const markLine = editors[i].session.getLine(0);\r\n                \r\n                const list = settingsElement.appendChild(document.createElement('ul'));\r\n                items.forEach((point, j) => {\r\n                    let itemElement = list.appendChild(document.createElement('li'));\r\n                    itemElement.innerText = point;\r\n                    \r\n                    let mark = markLine.match(new RegExp('/\\\\\\* (' + point + ') \\\\\\*/'));\r\n                    \r\n                    if (!j) settingsElement.selectedElement = itemElement;\r\n                    else if (mark) {\r\n                        // mark[1]\r\n                        settingsElement.selectedElement = itemElement;\r\n                        settingsElement.dispatchEvent(new CustomEvent('selected_changed', {\r\n                            detail: {\r\n                                // id: itemElement.id,\r\n                                value: point\r\n                            }\r\n                        }))\r\n                    }                    \r\n                })\r\n\r\n            }\r\n        })\r\n    }\r\n\r\n\r\n    /**\r\n     * terminal button:\r\n     */\r\n    let terminal = editors[2].container.appendChild(document.createElement('div'));\r\n    terminal.className = 'terminal'\r\n    terminal.onclick = () => {\r\n        \r\n        const logContainer = document.querySelector('.console');\r\n        const play = document.querySelector('.play');\r\n        const save = document.querySelector('.save');\r\n\r\n        // don`t work for mobile chrome (for some reason):        \r\n        // logContainer.parentElement.style.zIndex = 6 + '';\r\n\r\n\r\n        //@ts-ignore\r\n        if (logContainer && !logContainer.classList.toggle('hidden'))\r\n        {\r\n            let input = logContainer.querySelector('input');\r\n            input.focus()\r\n        }\r\n\r\n        play.classList.toggle('hidden');\r\n        save && save.classList.toggle('hidden');\r\n    }\r\n\r\n\r\n\r\n    let [iframe, curUrl] = createPage(playgroundObject.curUrl, frameworkEnvironment, jsxMode ? babelCompiler.mode : undefined)  // editorOptions\r\n\r\n    playgroundObject.iframe = iframe;\r\n    playgroundObject.curUrl = curUrl;\r\n\r\n\r\n    document.querySelector('.play').addEventListener('click', () => webCompile(jsxMode, frameworkEnvironment));\r\n    document.querySelector('.expand')['onclick'] = (/** @type {{ currentTarget: any; }} */ e) => expand(e, frameworkEnvironment, jsxMode ? babelCompiler.mode : undefined);\r\n    document.getElementById('compiler_mode').onchange = function (event) {\r\n\r\n        // @ts-ignore\r\n        (editorOptions.storage || localStorage).setItem('mode', event.target.selectedIndex)\r\n\r\n        // @ts-ignore\r\n        if (event.target.selectedIndex || true) location.reload()\r\n        else {\r\n            for (let i = 0; i < editors.length; i++) {\r\n                //@ts-ignore\r\n                let value = (editorOptions.storage || localStorage).getItem(event.target.selectedIndex + '__' + modes[i]) || '';\r\n                editors[i].session.setValue(value)  \r\n            }\r\n            // document.querySelector('.play').click();\r\n        }\r\n\r\n        // localStorage.setItem('mode', event.target.selectedOptions[event.target.selectedIndex].value)\r\n        // console.log(event.target.selectedIndex);\r\n    };\r\n    \r\n    \r\n    options.tabAttachSelector && document.querySelector(options.tabAttachSelector).addEventListener('click', function (e) {\r\n        e['editors'] = editors;\r\n        fileAttach(e);\r\n    });\r\n\r\n    editors.playgroundObject = playgroundObject;\r\n    editors.updateEnv = updateEnv;\r\n\r\n    return editors;\r\n}\r\n\r\n\r\n// export const {editors}"],"names":["isNumber","code","isAlpha","from","to","isAlphaNumericWord","isAlphaWord","isSpace","isWhiteSpace","isQuote","Scanner","constructor","str","start","end","length","this","string","pos","eof","limit","peek","charCodeAt","next","eat","match","ch","ok","eatWhile","backUp","n","current","substring","slice","error","message","ScannerError","Error","super","scanner","tokens","readable","size","consume","test","token","err","statements","options","result","type","elements","node","ctx","stack","element","group","push","isChildOperator","isSiblingOperator","isClimbOperator","pop","isGroupStart","isBracket","repeat","isRepeater","repeater","attr","elem","name","attributes","value","selfClose","jsx","isCapitalizedLiteral","isClassNameOperator","isElementName","elementName","isEmpty","text","getText","shortAttribute","attributeSet","isCloseOperator","concat","Array","isArray","isAttributeSetStart","attribute","isAttributeSetEnd","isOperator","expression","literal","quoted","isEquals","quote","single","allowBrackets","brackets","context","open","isTextStart","isOpen","Boolean","operator","isSingle","isLiteral","escaped","getToken","index","Number","consumePlaceholder","field","repeaterPlaceholder","reverse","base","parent","repeaterNumber","count","implicit","repeater$1","whiteSpace","isAllowedOperator","isElementName$1","isAllowedSpace","isAllowedRepeater","isQuote$1","bracketType","literal$1","op","operatorType","isOpenBracket","bracket","stream","operators","child","class","climb","id","equal","close","sibling","tokenVisitor","Literal","Quote","Bracket","Operator","Field","state","getVariable","RepeaterPlaceholder","i","repeaters","inserted","RepeaterNumber","lastIx","parentIx","Math","max","parentRepeater","String","WhiteSpace","stringify","urlRegex","emailRegex","convert","abbr","cleanText","textInserted","filter","s","trim","children","convertGroup","repeatGuard","maxRepeat","POSITIVE_INFINITY","_a","undefined","join","varValue","variables","deepest","deepestNode","last","insertText","href","startsWith","hrefAttribute","find","valueType","insertHref","convertStatement","original","Object","assign","items","isGroup","convertElement","target","stringifyName","stringifyValue","selfClosing","convertAttribute","some","isField","item","attachRepeater","implied","isBoolean","shift","boolean","arr","parseAbbreviation","abbreviation","source","tokenize","short","afterNegative","hasDecimal","prevPos","hasFloat","consumeNumber","rawValue","unit","numberValue","valueStart","color","alpha","isHex","colorAlpha","r","g","b","a","parseInt","parseColor","raw","createLiteral","colorValue","finished","stringValue","isIdentPrefix","isKeyword","shouldConsumeDashAfter","mergeTokens","consumeProperty","valueFragment","important","valueMode","isLiteral$1","t1","t2","isFunctionStart","isValueDelimiter","isImportant","consumeValue","isFragmentDelimiter","inArgument","args","isValue","consumeArguments","arguments","isCloseBracket","isArgumentDelimiter","isBracket$1","parse","tokenScanner","property","parser","mergeValue","prev","glue","append","t","mergeDeclarations","dest","src","config","findDeepest","isNode","walkResolve","resolve","resolved","mergeNodes","createOutputStream","level","offset","line","column","_push","processText","pushString","lines","split","splitByLines","il","pushNewline","indent","baseIndent","pushIndent","pushField","placeholder","attrName","strCase","attrQuote","isBooleanAttribute","includes","toLowerCase","isInline","inlineElements","toUpperCase","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","map","resolveImplicitTag","ancestors","getParentElement","contextName","parentName","vocabularies","ru","common","words","sp","latin","reLorem","rand","floor","random","sample","len","iterations","min","sentence","word","val","insertCommas","hasComma","totalCommas","paragraph","dict","wordCount","startWithCommon","totalWords","rename","isAllowed","reElement","reModifier","blockCandidates1","className","blockCandidates2","bem","data","getBEMData","classNames","cl","ix","indexOf","uniqueClass","block","findBlockName","updateClass","expandClassNames","path","m","prefix","originalClass","getBlockName","arrClassNames","expandShortNotation","_bem","classValue","parseBEM","depth","getBEMDataFromContext","walk$1","visitor","callback","forEach","createWalkState","out","caret","isSnippet","isInlineElement","pushTokens","largestIndex","shouldOutputAttribute","template","namePos","afterPos","isTokenStart","isToken","before","after","shouldComment","comment","enabled","trigger","output","attrs","htmlTagRegex","html","createCommentState","format","shouldFormat","getIndent","tagName","commentNodeBefore","pushAttribute","pushSnippet","innerFormat","hasNewline","matches","exec","startsWithBlockTag","commentNodeAfter","lQuote","rQuote","fieldIx","findIndex","trimLeft","adjacentInline","indentFormat","element$1","primary","secondary","isPrimaryAttribute","collectAttributes","shouldFormat$1","beforeName","afterName","replace","pushPrimaryAttributes","beforeAttribute","booleanValue","glueAttribute","afterAttribute","pushSecondaryAttributes","splitByLines$1","lineLengths","maxLength","valueLength","beforeTextLine","afterTextLine","pushValue","formatters","haml","slim","pug","oldTextValue","parseOpt","parse$2","reversed","snippet","snippets","snippetAbbr","topNode","resolveSnippets","fn","walk","transform","implicitTag","lookup","mergeAttributes","db","minWordCount","findRepeater","lorem","syntax","xsl","reProperty","opt","createSnippet","key","keywords","parsed","parseValue","cssVal","collectKeywords","dependencies","snippetsSort","parse$3","isProperty","v","scoreMatch","str1","str2","partialMatch","str1Len","str2Len","minLength","j","score","ch1","ch2","found","acronym","delta","sum","shortHex","isShortHex","toShortHex","toHex","asHex","values","frac","asRGB","num","digits","toFixed","hex","toString","pad","isJSON","_","letter","getSingleNumeric","getQuote","outputValue","propertyValue","outputImportant","outputToken","separator","prevEnd","gradientName","parse$1","cache","stylesheetSnippets","keys","sort","cur","nest","convertSnippets","isValueScope","filteredSnippets","getSnippetsForScope","resolveNode","gradientFn","cssValue","resolveGradient","propName","resolveValueKeywords","findBestMatch","inlineValue","lastPos","getUnmatchedPart","kw","resolveKeyword","defaultValue","hasField","wrapWithField","resolveAsProperty","reField","inputValue","tail","resolveAsSnippet","aliases","unitless","resolveNumericValue","minScore","matchedItem","maxScore","getScoringPart","ref","dep","q","defaultSyntaxes","markup","stylesheet","defaultConfig","lang","locale","charset","indentation","newline","e","x","syntaxConfig","parseSnippets","basefont","br","frame","hr","bdo","col","link","meta","style","script","img","picture","iframe","embed","param","area","form","label","input","inp","isindex","textarea","marquee","keygen","command","bq","fig","figc","pic","ifr","emb","obj","cap","colg","fst","btn","optg","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","mn","tem","fset","datag","datal","kg","det","cmd","doc","c","xhtml","xml","call","ap","api","imp","inc","ot","if","par","pare","var","vare","wp","cp","co","tex","com","msg","fall","nam","pres","strip","proc","choose","ac","ai","anim","animdel","animdir","animdur","animfm","animic","animn","animps","animtf","as","bd","bdb","bdbc","bdbi","bdbk","bdbli","bdblrs","bdbri","bdbrrs","bdbs","bdbw","bdc","bdci","bdcl","bdf","bdi","bdl","bdlc","bdlen","bdli","bdls","bdlw","bdr","bdrc","bdri","bdrs","bdrst","bdrw","bds","bdsp","bdt","bdtc","bdti","bdtli","bdtlrs","bdtri","bdtrrs","bdts","bdtw","bdw","bfv","bg","bga","bgbk","bgc","bgcp","bgi","bgo","bgp","bgpx","bgpy","bgr","bgsz","bxsh","bxsz","cr","cra","cm","cnt","coi","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","cor","cps","d","ec","f","fd","fef","fem","femp","fems","ff","fft","ffa","ffv","fl","fs","fsm","fv","fvs","fw","fx","fxb","fxd","fxf","fxg","fxsh","fxw","fsz","fsza","gtc","gtr","gta","gt","gg","gcg","grg","gac","gar","gaf","gd","gc","gcs","gce","gr","grs","gre","ga","h","jc","ji","js","l","lg","lh","lis","lisi","lisp","list","lts","mah","mar","maw","mb","mih","mir","miw","ml","mr","mt","olc","olo","ols","olw","ord","ori","orp","ov","ovs","ovx","ovy","pb","pgba","pgbb","pgbi","pl","pr","pt","qen","qru","rsz","ta","tal","tbl","td","te","th","ti","tj","tov","trf","trfo","trfs","trs","trsde","trsdu","trsp","trstf","tsh","tt","tw","us","va","w","whs","whsc","wid","wm","wob","wos","wow","z","zom","sass","stylus","k","mergedData","globals","typeDefaults","typeOverride","syntaxDefaults","syntaxOverride","expandAbbreviation","resolvedConfig","resolveConfig","css","preactCompiler","set","document","location","origin","host","babelCompiler","mode","compilers","vanile","preact","vue","react","reactDOM","defaultValues","javascript","generateGlobalInintializer","it","reduce","ChoiceMenu","HTMLElement","itemStyle","selectedElement","checkedElement","rootElement","checkInfo","itemInitialize","el","onclick","selectedChanged","selectedIndex","querySelectorAll","querySelector","selectedItem","innerText","getElementById","content","cloneNode","attachShadow","appendChild","shadowRoot","self","addEventListener","event","assignedElements","pickItem","visibleChanged","opened","classList","contains","setTimeout","toggle","dispatchEvent","CustomEvent","detail","top","offsetTop","offsetHeight","right","offsetWidth","remove","add","metaId","dataset","static","body","insertAdjacentHTML","modes","playgroundObject","editors","curUrl","fileStorage","_active","onfilerename","onfileRemove","createPage","prevUrl","additionalScripts","scriptType","window","getValue","_fs","appCode","langMode","getLangMode","currentLang","scriptID","originScript","createElement","onload","waiting","parentElement","removeChild","frameInfo","head","baseTags","editor","modeMenu","container","actualMode","console","log","tag","inside","blob","Blob","baseModes","URL","createObjectURL","htmlContent","acc","globalReinitializer","buildAndTranspile","terminalJar","loclog","postMessage","fromCharCode","onmessage","globalThis","eval","JSON","innerHTML","onmessageFunc","buildJS","optionalScripts","nodeCreate","nodeStruct","_attrs","createHtml","__debug","file","revokeObjectURL","url","view","sandbox","default","warn","compileFunc","webCompile","jsxMode","compilerModes","less","activeTab","contentDocument","lastScript","getLang","compiler","commonStorage","localStorage","getItem","setItem","modulesStore","fileName","sessionStorage","langModeMatch","expand","wrapper","display","collapseButton","currentTarget","title","domFuncs","render","desc","sign","component","return","useRef","initialValue","useState","initialState","useEffect","effect","inputs","qf","qm","fore","getComputedStyle","insertBefore","preventDefault","closest","selector","oninput","onkeydown","onchange","onmousedown","onmousemove","onmouseover","onmouseout","keyWords","metaInfo","caption","menuPoints","confirm","fileAttach","fileStore","filename","prompt","ext","session","getLine","alert","importSnippet","origTab","ondblclick","prevName","fileInfo","fullname","renameOccurrences","getSession","ev","prevTab","prevTabName","exports","ex","exprWords","setValue","gotoLine","focus","newTab","marginRight","oncontextmenu","contextMenu","tabIndex","point","onblur","left","clientX","clientY","keyWordInfo","hint","completers","getCompletions","getDocTooltip","arg","docHTML","argsDesc","description","autocompleteExpand","ace","require","snippetManager","insertSnippet","initializeEditor","editorOptions","syntaxMode","Range","autoPlay","func","delay","inAwaiting","debounce","bind","frameworkEnvironment","quickCompileMode","fontSize","cssKeyWords","edit","setTheme","setMode","setFontSize","storage","allCommands","commands","byName","removeCommand","removeline","copylinesdown","bindKey","win","mac","addCommand","textInput","getElement","ctrlKey","keyCode","controlSave","outerWidth","setOptions","enableBasicAutocompletion","enableSnippets","enableLiveAutocompletion","cursorText","tabHandler","completer","keyboardHandler","Tab","removeEventListener","cursor","getCursorPosition","row","startChar","lastIndexOf","endChar","range","textRange","extend","moveCursorTo","on","colorsCompleter","domCompleter","position","getTokenAt","newValue","wrap","wholeWord","threshold","findAll","pattern","RegExp","regExp","getSelectedText","storeName","module","replacePattern","linesCount","removeSelectionMarkers","$selectionMarkers","submatch","tabs","click","modulesStorage","_modules","fileCreateTab","hasOwnProperty","hrSplitter","vertSplitter","centerSplitter","htmlEditor","styleEditor","jsEditor","editionView","hoSeized","vertSeized","allSeized","headerHeight","getBoundingClientRect","paddingTop","parseFloat","padding","initResizers","resize","hTune","pref","prefLine","post","width","vTune","marginTop","height","lowerHeight","evalCode","contentWindow","snipElem","textContent","marginBottom","shellStore","shellStoreLength","currentShellStoreIndex","selectionStart","selectionEnd","updateEnvironment","fwrkEnv","envName","libs","splice","lib","consoleJar","fontFamily","scrollTo","scrollHeight","updateEnv","onControlSave","additionalFiles","customElements","get","define","settingsElement","modeOptions","multitabs","transition","markLine","markValue","insert","jsPattern","tsPattern","endsWith","extensions","storageFiles","firstTab","itemElement","mark","terminal","logContainer","play","save","reload","tabAttachSelector"],"mappings":"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"}