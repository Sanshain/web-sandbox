{"version":3,"file":"bundler.js","sources":["../node_modules/tcp-bundler/pack.js","../node_modules/tcp-bundler/index.js","../source/utils/bundler.js"],"sourcesContent":["//@ts-check\r\n// import \"fs\";\r\n\r\nconst extensions = ['.ts','.js']\r\nvar exportedFiles = []\r\n\r\n// integrate(\"base.ts\", 'result.js')\r\n\r\nexports.combine = combine;\r\n// exports.integrate = integrate;\r\n\r\n/**\r\n * @param {string} content\r\n * @param {string} dirpath\r\n * @param {any} options\r\n */\r\nfunction combine(content, dirpath, options){\r\n    \r\n    exportedFiles = []\r\n\r\n    content = removeLazy(content)\r\n\r\n    content = importInsert(content, dirpath, options);\r\n\r\n    return content;\r\n}\r\n\r\n// function integrate(from, to, options){    \r\n\r\n//     let content = fs.readFileSync(from).toString();        \r\n//     let filename = path.resolve(from);\r\n    \r\n//     content = combine(content, path.dirname(filename), options)\r\n\r\n//     to = to || path.parse(filename).dir + path.sep + path.parse(filename).name + '.js';\r\n\r\n//     fs.writeFileSync(to, content)    \r\n// }\r\n\r\nclass pathMan {\r\n    /**\r\n     * @param {string} dirname\r\n     * @param {any} _getContent\r\n     */\r\n    constructor(dirname, _getContent) {\r\n        this.dirPath = dirname;\r\n        this.getContent = _getContent;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @param {string} dirpath\r\n * @param {{ getContent: Function; release: any; }} options\r\n */\r\nfunction importInsert(content, dirpath, options) {\r\n    \r\n    console.log('importInsert...');\r\n\r\n    let pathman = new pathMan(dirpath, options.getContent || getContent);\r\n    \r\n    let regex = /^import \\* as (?<module>\\w+) from \\\"\\.\\/(?<filename>\\w+)\\\";?/gm;            \r\n    content = content.replace(regex, unitsPack.bind(pathman));\r\n\r\n    ///* not recommended, but easy for realization:\r\n    // regex = /^import \\\"\\.\\/(?<filename>\\w+)\\\"/gm;\r\n    // content = content.replace(regex, allocPack.bind(pathman)); //*/    \r\n\r\n    regex = /^import {([\\w, ]+)} from ['\"]\\.\\/([\\w\\.]+)['\"];?/gm\r\n    content = content.replace(regex, wrapsPack.bind(pathman)); //*/\r\n\r\n    regex = /^import ([\\w, ]+) from ['\"].\\/([\\w\\.\\/]+)['\"];?/gm;\r\n    content = content.replace(regex, defaultPack.bind(pathman)); //*/\r\n    \r\n    if (options && options.release)\r\n    {\r\n        // remove comments:\r\n        content = content.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\r\n        content = content.replace(/\\/\\/[\\s\\S]*?\\n/g, '\\n'); //*/\r\n    }\r\n\r\n    return content\r\n}\r\n\r\n\r\n/**\r\n * @param {string} match\r\n * @param {string|string[]} classNames\r\n * @param {any} fileName\r\n * @param {any} offset\r\n * @param {any} source\r\n */\r\nfunction defaultPack(match, classNames, fileName, offset, source) {\r\n\r\n    var content = this.getContent(fileName)\r\n    if (content == '' || !content) return ''\r\n\r\n    //@ts-ignore\r\n    classNames = classNames.split(',').map(s => s.trim())\r\n    const matches = Array.from(content.matchAll(/^export default (function|class) (\\w+)[ ]*\\([\\w, ]*\\)[\\s]*{[\\w\\W]*?\\n}/gm))        \r\n\r\n    console.log(match);\r\n    match = '';\r\n    for (let unit of matches) {\r\n        if (classNames.includes(unit[2])) {\r\n\r\n            match += unit[0].substr(7).replace('default ', '') + '\\n\\n'\r\n        }\r\n    }\r\n\r\n    content = `\\n/*start of ${fileName}*/\\n${match.trim()}\\n/*end*/\\n\\n`\r\n\r\n    return content;\r\n}\r\n\r\n\r\n/**\r\n * @param {string} match\r\n * @param {string} classNames\r\n * @param {any} fileName\r\n * @param {any} offset\r\n * @param {any} source\r\n */\r\nfunction wrapsPack(match, classNames, fileName, offset, source){\r\n\r\n    console.log('wrapsPack...');\r\n\r\n    var content = this.getContent(fileName)\r\n    if (content == '' || !content) return ''\r\n\r\n    //@ts-ignore\r\n    classNames = classNames.split(',').map(s => s.trim())\r\n\r\n    // let matches1 = Array.from(content.matchAll(/^export (let|var) (\\w+) = [^\\n]+/gm))\r\n    // with ts support:\r\n    let matches1 = Array.from(content.matchAll(/^export (let|var) (\\w+) ?(\\: [\\<\\>\\[\\]\\w\\|]+)? = [^\\n]+/gm))\r\n\r\n    // let matches2 = Array.from(content.matchAll(/^export (function) (\\w+)[ ]*\\([\\w, ]*\\)[\\s]*{[\\w\\W]*?\\n}/gm))\r\n    // with ts support:\r\n    let matches2 = Array.from(content.matchAll(/^export (function) (\\w+)[ ]*\\([\\w, \\:\\<\\>\\[\\]\\|&\\{\\}]*\\)(: [\\w\\|\\<\\>\\{\\} :]+)?[\\s]*{[\\w\\W]*?\\n}/gm))\r\n\r\n\r\n    let matches3 = Array.from(content.matchAll(/^export (class) (\\w+)([\\s]*{[\\w\\W]*?\\n})/gm))\r\n    var matches = matches1.concat(matches2, matches3);\r\n\r\n    match = ''\r\n    for (let unit of matches)\r\n    {\r\n        if (classNames.includes(unit[2])){\r\n            \r\n            match += unit[0].substr(7) + '\\n\\n'\r\n        }        \r\n    }\r\n    \r\n    content = `\\n/*start of ${fileName}*/\\n${match.trim()}\\n/*end*/\\n\\n` \r\n\r\n    return content;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @param {any} match\r\n * @param {any} modulName\r\n * @param {any} fileName\r\n * @param {any} offset\r\n * @param {any} source\r\n */\r\nfunction unitsPack(match, modulName, fileName, offset, source){\r\n\r\n    var content = this.getContent(fileName)\r\n    if (content == '' || !content) return ''\r\n\r\n    let exportList = []\r\n\r\n    content = content.replace(/^(let|var) /gm, 'let ')\r\n    content = content.replace(/^export (let|var|function|class) (\\w+)/gm, \r\n    function(/** @type {any} */ match, /** @type {string} */ declType, /** @type {string} */ varName, /** @type {any} */ offset, /** @type {any} */ source)\r\n    {\r\n        // exportList[varName] = varName\r\n\r\n        let postfix = ''\r\n        if (declType == 'function') postfix = '.bind(window)'\r\n        exportList.push('\\t\\t' + varName + \":\" + varName)\r\n        return declType + ' ' + varName;\r\n    });\r\n\r\n    var unitObj = exportList.join(',\\n')\r\n    content += `\\n\\nvar ${modulName} = {\\n ${unitObj} \\n}`\r\n\r\n    content = '{\\n' + content.replace(/^([\\S \\t])/gm, '    $1') + '\\n}'    \r\n\r\n    content = `\\n/*start of ${fileName}*/\\n${content}\\n/*end*/\\n\\n`    \r\n\r\n    return content;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Obsolete!\r\n * @param {RegExp} match regular expression\r\n * @param {string} fileName file name\r\n * @param {*} offset \r\n * @param {string} source \r\n * @returns {string}\r\n */\r\nfunction allocPack(match, fileName, offset, source){\r\n\r\n    var content = this.getContent(fileName)\r\n    if (content == '') return ''\r\n\r\n    var simple = false;\r\n    if (simple){\r\n        // w/o unique check of variable names! ie- supports\r\n        content = content.replace(/^export /gm, '')    \r\n    }\r\n    else{\r\n        // vs unique check of variable names! ie11+\r\n        content = content.replace(/^(let|var) /gm, 'let ')\r\n        content = content.replace(/^export (let|var) /gm, 'let ')            \r\n        content = content.replace(/^export function (?<funcname>\\w+)\\(/gm, 'let $1 = function(')\r\n        \r\n        var warn = /^export (class) (\\w+)/gm.exec(content);\r\n        if (warn){\r\n            throw new Error(`use \"import {${warn[2]}} from './${fileName}'\" `+\r\n                        `statement for class import instead of common import *`)\r\n        }\r\n        content = '{\\n' + content.replace(/^([\\S])/gm, '    $1') + '\\n}'\r\n        \r\n    }\r\n    \r\n    content = `\\n/*start of ${fileName}*/\\n${content}\\n/*end*/\\n\\n`    \r\n\r\n    return content;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @param {fs.PathOrFileDescriptor} fileName\r\n */\r\nfunction getContent(fileName){    \r\n\r\n    const fs = require(\"fs\");\r\n\r\n    fileName = this.dirPath + '/' + fileName\r\n\r\n    for(let ext of extensions){\r\n        if (fs.existsSync(fileName + ext)) \r\n        {   \r\n            fileName = fileName + ext;\r\n            break;            \r\n        }\r\n    }\r\n\r\n    if (exportedFiles.includes(fileName)) \r\n    {\r\n        \r\n        // let lineNumber = source.substr(0, offset).split('\\n').length\r\n        console.warn(`attempting to re-import '${fileName}' into 'base.ts' has been rejected`);\r\n        return ''\r\n    }\r\n    else exportedFiles.push(fileName)\r\n    \r\n\r\n    var content = fs.readFileSync(fileName).toString()    \r\n\r\n    // content = Convert(content)\r\n\r\n    return content;\r\n}\r\n\r\n/**\r\n * Remove lazy-marked chunk of code:\r\n * \r\n * @param {string} content : content;\r\n * @returns {string}\r\n */\r\nfunction removeLazy(content){    \r\n\r\n    return content.replace(/\\/\\*-lazy\\*\\/[\\s\\S]*?\\/\\*lazy-\\*\\//, '');    \r\n}\r\n","\r\n// const fs = require(\"fs\");\r\n// const sock = require('net');\r\n// const path = require('path')\r\n\r\n// // const cmd = require(\"child_process\");\r\n// var tss = require('typescript-simple');\r\n// var obfuscator = require(\"uglify-js\");\r\n\r\nconst build = require('./pack').combine;\r\n\r\n// function startListen(host, port, options){\r\n// \thost = host || 'localhost'\r\n// \tport = port || 9098\r\n// \toptions = options || {}\r\n\r\n// \tconsole.log(`bundler start listen on ${host}:${port}`)    \t\r\n\r\n// \tsock.createServer(function (socket) {\r\n\r\n// \t\tconsole.log('connection estableshed')    \r\n\t\r\n// \t\tsocket.on('data', async function(data) {\r\n\t\t\t \t\t\t\r\n// \t\t\tconsole.time('Time');\t\t\r\n\t\r\n// \t\t\tlet filename = data.toString();\r\n// \t\t\tconsole.log(`received task for '${filename}'`)\r\n\t\t\t\t\r\n// \t\t\tif (fs.existsSync(filename)){\r\n\t\r\n// \t\t\t\tvar content = fs.readFileSync(filename, \"utf8\");\r\n// \t\t\t\tvar result = bundler.combine(content, path.dirname(filename), options)\r\n\t\t\t\t\r\n// \t\t\t\tif (options.tsc)  result = tss(result);\t\t\r\n// \t\t\t\tif (options.minify)\tresult = obfuscator.minify(result).code.valueOf();\t\t\t\t\r\n// \t\t\t\tlet pathinfo = path.parse(filename);\r\n\r\n// \t\t\t\tfs.writeFileSync(pathinfo.dir + path.sep + pathinfo.name + '.js', result)\r\n// \t\t\t}\r\n// \t\t\telse throw new Error(`file ${filename} does not exists`)\r\n\t\t\t\t\t\r\n// \t\t\tconsole.timeEnd('Time');\r\n// \t\t\tsocket.write('success');\r\n\r\n// \t\t});\r\n\t\t \r\n// \t}).listen(port, host);\r\n\r\n// }\r\n\r\nmodule.exports = { build }\r\n\r\n\r\n\r\n/*\r\nvar s = require('net').Socket();\r\ns.connect(8080, 'localhost');\r\ns.write('Hello');\r\ns.end();\r\n//*/","import { build } from 'tcp-bundler';\r\n\r\n/**\r\n * билдит модули (пока тож не используется нигде, вроде)\r\n * @param {string} content : ;\r\n * @param {object} store \r\n * @return {string}\r\n */\r\nexport default function plainBuild(content, store) {\r\n\r\n    let exportedFiles = [];\r\n\r\n    // console.log(build);\r\n\r\n    \r\n    let bb = build;\r\n    globalThis.__debug && console.log(bb);\r\n\r\n\r\n    let result = build(content, '.', {\r\n        getContent: function (fileName) {\r\n\r\n            // fileName = path.normalize(this.dirPath + '/' + fileName)\r\n\r\n            //! один файл можно импотрировать только один раз !//\r\n\r\n            if (~exportedFiles.indexOf(fileName)) { console.warn(`attempting to re-import '${fileName}' into 'base.ts' has been rejected`); return ''; }\r\n            else {\r\n                exportedFiles.push(fileName)\r\n            }\r\n\r\n            let content = store[fileName];          // var content = fs.readFileSync(fileName).toString()    // store['app.js'] || \r\n\r\n            return content;\r\n        }\r\n    });\r\n\r\n    //@ts-ignore\r\n    // try {\r\n    //     editors[2].completers.push(exportCompleter);\r\n    // }\r\n    // catch (exc) {\r\n    //     console.warn('empty editors...');\r\n    // }\r\n\r\n    return result;\r\n}\r\n\r\n\r\n// simplest dyncmic custom autocomplete\r\n\r\nconst exportTable = [\r\n    {\r\n        caption: 'someFunc',\r\n        value: 'someFunc',\r\n        meta: 'local'\r\n    }\r\n]\r\n\r\nvar exportCompleter = {\r\n    getCompletions: function (editor, session, pos, prefix, callback) {\r\n        callback(null, exportTable);\r\n    }\r\n};\r\n\r\n\r\n\r\nconst splitAt = (x, index) => [x.slice(0, index), x.slice(index)]\r\n\r\n/**\r\n * Функция для нативного импорта\r\n * \r\n * (не используется?)\r\n * @param {string} content : ;\r\n * @param {*} store \r\n */\r\nexport function thisBuild(content, store){\r\n\r\n    function createModule(match, classNames, fileName, offset, source) {\r\n\r\n        console.log(source);\r\n        let [expr, file] = splitAt(splitAt, offset);\r\n        \r\n        let blob = new Blob([store[fileName]], { type: 'text/html' });\r\n        let url = URL.createObjectURL(blob);\r\n\r\n        return expr + file.replace(fileName, '/' + url.split('/').pop());\r\n    }\r\n\r\n    let regex;\r\n\r\n    regex = /^import {([\\w, ]+)} from ['\"](\\.\\/[\\w\\.]+)['\"];?/gm\r\n    content = content.replace(regex, createModule); //*/\r\n\r\n    regex = /^import ([\\w, ]+) from ['\"](.\\/[\\w\\.\\/]+)['\"];?/gm;\r\n    content = content.replace(regex, createModule); //*/\r\n}\r\n\r\n"],"names":["extensions","exportedFiles","pack","combine","content","dirpath","options","console","log","pathman","pathMan","getContent","regex","replace","unitsPack","bind","wrapsPack","defaultPack","release","importInsert","removeLazy","constructor","dirname","_getContent","this","dirPath","match","classNames","fileName","offset","source","split","map","s","trim","matches","Array","from","matchAll","unit","includes","substr","matches1","matches2","matches3","concat","modulName","exportList","declType","varName","push","join","fs","require$$0","ext","existsSync","warn","readFileSync","toString","tcpBundler","build","splitAt","x","index","slice","store","bb","globalThis","__debug","indexOf","createModule","expr","file","blob","Blob","type","url","URL","createObjectURL","pop"],"mappings":"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"}